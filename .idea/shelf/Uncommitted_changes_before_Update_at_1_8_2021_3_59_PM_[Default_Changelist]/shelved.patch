Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import matplotlib\r\nimport numpy as np\r\nimport heapq\r\n\r\nfrom numpy.random import  randint\r\nimport matplotlib.pyplot as plt\r\n\r\n\r\nclass Node:\r\n    def __init__(self, key, v1, v2):\r\n        self.key = key\r\n        self.v1 = v1\r\n        self.v2 = v2\r\n\r\n    def __eq__(self, other):\r\n        return np.sum(np.abs(self.key - other.key)) == 0\r\n\r\n    def __ne__(self, other):\r\n        return self.key != other.key\r\n\r\n    def __lt__(self, other):\r\n        return (self.v1, self.v2) < (other.v1, other.v2)\r\n\r\n    def __le__(self, other):\r\n        return (self.v1, self.v2) <= (other.v1, other.v2)\r\n\r\n    def __gt__(self, other):\r\n        return (self.v1, self.v2) > (other.v1, other.v2)\r\n\r\n    def __ge__(self, other):\r\n        return (self.v1, self.v2) >= (other.v1, other.v2)\r\n\r\n\r\nclass DStarLite:\r\n    def __init__(self, r_map, sx, sy, gx, gy):\r\n        self.start = np.array([sx, sy])\r\n        self.goal = np.array([gx, gy])\r\n        self.k_m = 0\r\n        self.rhs = np.ones((r_map.shape[0], r_map.shape[1])) * np.inf\r\n        self.g = self.rhs.copy()\r\n        self.graph = r_map\r\n        self.sensed_map = np.zeros((len(r_map), len(r_map[0])))\r\n        self.rhs[self.goal[0], self.goal[1]] = 0\r\n        self.queue = []\r\n        node = Node(self.goal, *self.CalculateKey(self.goal))\r\n        heapq.heappush(self.queue, node)\r\n\r\n    def CalculateKey(self, node):\r\n        key = [0, 0]\r\n        key[0] = min(self.g[node[0], node[1]], self.rhs[node[0], node[1]]) + self.h_estimate(self.start, node) + self.k_m\r\n        key[1] = min(self.g[node[0], node[1]], self.rhs[node[0], node[1]])\r\n        return key\r\n\r\n    def UpdateVertex(self, u):\r\n        if np.sum(np.abs(u - self.goal)) != 0:\r\n            s_list = self.succ(u)\r\n            min_s = np.inf\r\n            for s in s_list:\r\n                if self.cost(u, s) + self.g[s[0], s[1]] < min_s:\r\n                    min_s = self.cost(u, s) + self.g[s[0], s[1]]\r\n            self.rhs[u[0], u[1]] = min_s\r\n        if Node(u, 0, 0) in self.queue:\r\n            self.queue.remove(Node(u, 0, 0))\r\n            heapq.heapify(self.queue)\r\n        if self.g[u[0], u[1]] != self.rhs[u[0], u[1]]:\r\n            heapq.heappush(self.queue, Node(u, *self.CalculateKey(u)))\r\n\r\n    def ComputeShortestPath(self):\r\n        while len(self.queue) > 0 and \\\r\n                heapq.nsmallest(1, self.queue)[0] < Node(self.start, *self.CalculateKey(self.start)) or \\\r\n                self.rhs[self.start[0], self.start[1]] != self.g[self.start[0], self.start[1]]:\r\n\r\n            k_old = heapq.nsmallest(1, self.queue)[0]\r\n            u = heapq.heappop(self.queue).key\r\n            if k_old < Node(u, *self.CalculateKey(u)):\r\n                heapq.heappush(self.queue, Node(u, *self.CalculateKey(u)))\r\n\r\n            # u = heapq.heappop(self.queue).key\r\n\r\n            elif self.g[u[0], u[1]] > self.rhs[u[0], u[1]]:\r\n                self.g[u[0], u[1]] = self.rhs[u[0], u[1]]\r\n                s_list = self.succ(u)\r\n                for s in s_list:\r\n                    self.UpdateVertex(s)\r\n            else:\r\n                self.g[u[0], u[1]] = np.inf\r\n                s_list = self.succ(u)\r\n                s_list.append(u)\r\n                for s in s_list:\r\n                    self.UpdateVertex(s)\r\n\r\n    # fetch successors and predessors\r\n    def succ(self, u):\r\n        s_list = [np.array([u[0] - 1, u[1] - 1]), np.array([u[0] - 1, u[1]]), np.array([u[0] - 1, u[1] + 1]),\r\n                  np.array([u[0], u[1] - 1]), np.array([u[0], u[1] + 1]), np.array([u[0] + 1, u[1] - 1]),\r\n                  np.array([u[0] + 1, u[1]]), np.array([u[0] + 1, u[1] + 1])]\r\n        row = len(self.graph)\r\n        col = len(self.graph[0])\r\n        real_list = []\r\n        for s in s_list:\r\n            if 0 <= s[0] < row and 0 <= s[1] < col:\r\n                real_list.append(s)\r\n        return real_list\r\n\r\n    #heuristic estimation\r\n    def h_estimate(self, s1, s2):\r\n        x_dist = s1[0] - s2[0]\r\n        y_dist = s1[1] - s2[1]\r\n        dist = np.sqrt(x_dist**2 + y_dist**2)\r\n        return dist\r\n    # def h_estimate(self, s1, s2):\r\n    #     return np.linalg.norm(s1 - s2)\r\n\r\n    # calculate cost between nodes\r\n    def cost(self, u1, u2):\r\n        if self.sensed_map[u1[0], u1[1]] == np.inf or self.sensed_map[u2[0], u2[1]] == np.inf:\r\n            return np.inf\r\n        else:\r\n            return self.h_estimate(u1, u2)\r\n\r\n    def sense(self, range_s):\r\n        real_list = []\r\n        row = len(self.graph)\r\n        col = len(self.graph[0])\r\n        for i in range(-range_s, range_s + 1):\r\n            for j in range(-range_s, range_s + 1):\r\n                if 0 <= self.start[0] + i < row and 0 <= self.start[1] + j < col:\r\n                    if not (i == 0 and j == 0):\r\n                        real_list.append(np.array([self.start[0] + i, self.start[1] + j]))\r\n        return real_list\r\n\r\n\r\ndef ScanAndUpdate(node, last):\r\n    s_list = node.sense(2)\r\n    flag = True\r\n    for s in s_list:\r\n        if node.sensed_map[s[0], s[1]] != node.graph[s[0], s[1]]:\r\n            flag = False\r\n            # print('See a wall!')\r\n            break\r\n    if not flag:\r\n        node.k_m += node.h_estimate(last, node.start)\r\n        last = node.start.copy()\r\n        for s in s_list:\r\n            if node.sensed_map[s[0], s[1]] != node.graph[s[0], s[1]]:\r\n                plt.plot(s[0], s[1], 'xr')\r\n                node.sensed_map[s[0], s[1]] = node.graph[s[0], s[1]]\r\n                node.UpdateVertex(s)\r\n        for i in range(len(node.queue)):\r\n            u = heapq.heappop(node.queue).key\r\n            temp = Node(u, *node.CalculateKey(u))\r\n            heapq.heappush(node.queue, temp)\r\n        heapq.heapify(node.queue)\r\n        node.ComputeShortestPath()\r\n    return last\r\n\r\n\r\ndef maze(width, height, complexity=.05, density=.05):\r\n    # Only odd shapes\r\n    shape = ((height // 2) * 2 + 1, (width // 2) * 2 + 1)\r\n    # Adjust complexity and density relative to maze size\r\n    complexity = int(complexity * (5 * (shape[0] + shape[1])))\r\n    density = int(density * (shape[0] // 2 * shape[1] // 2))\r\n\r\n    # Build actual maze\r\n    z = np.zeros(shape, dtype=float)\r\n    # Fill borders\r\n    z[0, :] = z[-1, :] = z[:, 0] = z[:, -1]= 1\r\n    # Make isles\r\n    for i in range(density):\r\n        x, y = randint(0, shape[1] // 2) * 2, randint(0, shape[0] // 2) * 2\r\n        z[y, x] = 1\r\n        for j in range(complexity):\r\n            neighbours = []\r\n            if x > 1:\r\n                neighbours.append((y, x - 2))\r\n            if x < shape[1] - 2:\r\n                neighbours.append((y, x + 2))\r\n            if y > 1:\r\n                neighbours.append((y - 2, x))\r\n            if y < shape[0] - 2:\r\n                neighbours.append((y + 2, x))\r\n            if len(neighbours):\r\n                y_, x_ = neighbours[randint(0, len(neighbours) - 1)]\r\n                if z[y_, x_] == 0:\r\n                    z[y_, x_] = 1\r\n                    z[y_ + (y - y_) // 2, x_ + (x - x_) // 2] = 1\r\n                    x, y = x_, y_\r\n    return z\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    # set start and goal point\r\n    sx = 0\r\n    sy = 0\r\n    gx = 19\r\n    gy = 19\r\n\r\n    # set obstable positions\r\n    graph = maze(width=20, height=20)\r\n    ox, oy = [], []\r\n    for i in range(0, len(graph)):\r\n        for j in range(0, len(graph[i])):\r\n            if graph[i][j] == 1:\r\n                ox.append(i)\r\n                oy.append(j)\r\n\r\n    graph[graph == 1] = np.inf\r\n    matplotlib.rc('figure', figsize=(5, 5))\r\n    plt.grid(True)\r\n    plt.plot([sx, gx], [sy, gy], 'r')\r\n    plt.plot(ox, oy, \".k\")\r\n    plt.plot(sx, sy, \"og\")\r\n    plt.plot(gx, gy, \"xb\")\r\n\r\n    dstar = DStarLite(graph, sx, sy, gx, gy)\r\n\r\n    last = dstar.start\r\n    last = ScanAndUpdate(dstar, last)\r\n    dstar.ComputeShortestPath()\r\n    while np.sum(np.abs(dstar.start - dstar.goal)) != 0:\r\n        s_list = dstar.succ(dstar.start)\r\n        min_s = np.inf\r\n        for s in s_list:\r\n            # plt.plot(s[0], s[1], 'xy')\r\n            if dstar.cost(dstar.start, s) + dstar.g[s[0], s[1]] < min_s:\r\n                min_s = dstar.cost(dstar.start, s) + dstar.g[s[0], s[1]]\r\n                temp = s\r\n        dstar.start = temp.copy()\r\n        # print(dstar.start[0], dstar.start[1])\r\n        plt.plot(dstar.start[0], dstar.start[1], '.b')\r\n        last = ScanAndUpdate(dstar, last)\r\n        plt.pause(0.1)\r\n    print(\"Goal Reached\")\r\n\r\n    plt.show()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision 4d6daa713219b065fe833c61153c3a22f1c5a250)
+++ b/main.py	(date 1610002885261)
@@ -2,7 +2,7 @@
 import numpy as np
 import heapq
 
-from numpy.random import  randint
+from numpy.random import randint
 import matplotlib.pyplot as plt
 
 
@@ -39,26 +39,35 @@
         self.rhs = np.ones((r_map.shape[0], r_map.shape[1])) * np.inf
         self.g = self.rhs.copy()
         self.graph = r_map
-        self.sensed_map = np.zeros((len(r_map), len(r_map[0])))
+        self.sensed_map = np.zeros((r_map.shape[0], r_map.shape[1]))
         self.rhs[self.goal[0], self.goal[1]] = 0
         self.queue = []
         node = Node(self.goal, *self.CalculateKey(self.goal))
         heapq.heappush(self.queue, node)
 
-    def CalculateKey(self, node):
+    # heuristic estimation
+    def h_estimate(self, s1, s2):
+        x_dist = s1[0] - s2[0]
+        y_dist = s1[1] - s2[1]
+        dist = np.sqrt(x_dist ** 2 + y_dist ** 2)
+        return dist
+
+    def CalculateKey(self, s):
         key = [0, 0]
-        key[0] = min(self.g[node[0], node[1]], self.rhs[node[0], node[1]]) + self.h_estimate(self.start, node) + self.k_m
-        key[1] = min(self.g[node[0], node[1]], self.rhs[node[0], node[1]])
+        key[0] = min(self.g[s[0], s[1]], self.rhs[s[0], s[1]]) + self.h_estimate(self.start, s) + self.k_m
+        key[1] = min(self.g[s[0], s[1]], self.rhs[s[0], s[1]])
         return key
 
     def UpdateVertex(self, u):
         if np.sum(np.abs(u - self.goal)) != 0:
             s_list = self.succ(u)
-            min_s = np.inf
+            min_s = []
+            # min_s = np.inf
             for s in s_list:
-                if self.cost(u, s) + self.g[s[0], s[1]] < min_s:
-                    min_s = self.cost(u, s) + self.g[s[0], s[1]]
-            self.rhs[u[0], u[1]] = min_s
+                min_s.append(self.cost(u, s) + self.g[s[0], s[1]])
+                # if self.cost(u, s) + self.g[s[0], s[1]] < min_s:
+                #     min_s =
+            self.rhs[u[0], u[1]] = min(min_s)
         if Node(u, 0, 0) in self.queue:
             self.queue.remove(Node(u, 0, 0))
             heapq.heapify(self.queue)
@@ -74,12 +83,9 @@
             u = heapq.heappop(self.queue).key
             if k_old < Node(u, *self.CalculateKey(u)):
                 heapq.heappush(self.queue, Node(u, *self.CalculateKey(u)))
-
-            # u = heapq.heappop(self.queue).key
-
             elif self.g[u[0], u[1]] > self.rhs[u[0], u[1]]:
                 self.g[u[0], u[1]] = self.rhs[u[0], u[1]]
-                s_list = self.succ(u)
+                s_list = self.succ(u)    #list of predessor
                 for s in s_list:
                     self.UpdateVertex(s)
             else:
@@ -89,7 +95,7 @@
                 for s in s_list:
                     self.UpdateVertex(s)
 
-    # fetch successors and predessors
+    # fetch successors and predessors but in our case both are same
     def succ(self, u):
         s_list = [np.array([u[0] - 1, u[1] - 1]), np.array([u[0] - 1, u[1]]), np.array([u[0] - 1, u[1] + 1]),
                   np.array([u[0], u[1] - 1]), np.array([u[0], u[1] + 1]), np.array([u[0] + 1, u[1] - 1]),
@@ -102,15 +108,6 @@
                 real_list.append(s)
         return real_list
 
-    #heuristic estimation
-    def h_estimate(self, s1, s2):
-        x_dist = s1[0] - s2[0]
-        y_dist = s1[1] - s2[1]
-        dist = np.sqrt(x_dist**2 + y_dist**2)
-        return dist
-    # def h_estimate(self, s1, s2):
-    #     return np.linalg.norm(s1 - s2)
-
     # calculate cost between nodes
     def cost(self, u1, u2):
         if self.sensed_map[u1[0], u1[1]] == np.inf or self.sensed_map[u2[0], u2[1]] == np.inf:
@@ -120,8 +117,8 @@
 
     def sense(self, range_s):
         real_list = []
-        row = len(self.graph)
-        col = len(self.graph[0])
+        row = self.graph.shape[0]
+        col = self.graph.shape[1]
         for i in range(-range_s, range_s + 1):
             for j in range(-range_s, range_s + 1):
                 if 0 <= self.start[0] + i < row and 0 <= self.start[1] + j < col:
@@ -130,32 +127,32 @@
         return real_list
 
 
-def ScanAndUpdate(node, last):
-    s_list = node.sense(2)
-    flag = True
-    for s in s_list:
-        if node.sensed_map[s[0], s[1]] != node.graph[s[0], s[1]]:
-            flag = False
+def ScanAndUpdate(present, last):
+    s_list = present.sense(3)
+    flag = False
+    for s in s_list:
+        if present.sensed_map[s[0], s[1]] != present.graph[s[0], s[1]]:
+            flag = True
             # print('See a wall!')
             break
-    if not flag:
-        node.k_m += node.h_estimate(last, node.start)
-        last = node.start.copy()
+    if flag:
+        present.k_m += present.h_estimate(last, present.start)
+        last = present.start.copy()
         for s in s_list:
-            if node.sensed_map[s[0], s[1]] != node.graph[s[0], s[1]]:
-                plt.plot(s[0], s[1], 'xr')
-                node.sensed_map[s[0], s[1]] = node.graph[s[0], s[1]]
-                node.UpdateVertex(s)
-        for i in range(len(node.queue)):
-            u = heapq.heappop(node.queue).key
-            temp = Node(u, *node.CalculateKey(u))
-            heapq.heappush(node.queue, temp)
-        heapq.heapify(node.queue)
-        node.ComputeShortestPath()
-    return last
+            if present.sensed_map[s[0], s[1]] != present.graph[s[0], s[1]]:
+                # plt.plot(s[0], s[1], 'xr')
+                present.sensed_map[s[0], s[1]] = present.graph[s[0], s[1]]
+                present.UpdateVertex(s)
+        for i in range(len(present.queue)):
+            u = heapq.heappop(present.queue).key
+            temp = Node(u, *present.CalculateKey(u))
+            heapq.heappush(present.queue, temp)
+        # heapq.heapify(present.queue)
+        present.ComputeShortestPath()
+    return
 
 
-def maze(width, height, complexity=.05, density=.05):
+def maze(width, height, complexity=.03, density=.1):
     # Only odd shapes
     shape = ((height // 2) * 2 + 1, (width // 2) * 2 + 1)
     # Adjust complexity and density relative to maze size
@@ -165,7 +162,7 @@
     # Build actual maze
     z = np.zeros(shape, dtype=float)
     # Fill borders
-    z[0, :] = z[-1, :] = z[:, 0] = z[:, -1]= 1
+    z[0, :] = z[-1, :] = z[:, 0] = z[:, -1] = 1
     # Make isles
     for i in range(density):
         x, y = randint(0, shape[1] // 2) * 2, randint(0, shape[0] // 2) * 2
@@ -197,7 +194,33 @@
     gy = 19
 
     # set obstable positions
-    graph = maze(width=20, height=20)
+    graph = np.array(
+        [[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0],
+         [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0],
+         [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0],
+         [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0],
+         [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0],
+         [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0],
+         [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0],
+         [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0],
+         [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0],
+         [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0],
+         [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0],
+         [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0],
+         [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0],
+         [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0],
+         [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0],
+         [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0],
+         [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0],
+         [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0],
+         [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0],
+         [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0],
+         [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]])
+    # graph = maze(width=20, height=20)
+    # v=[[graph[i][j] for j in range(graph.shape[1])] for i in range(graph.shape[0])]
+    # print(v)
+
+    # np.savetxt("graph.txt", v)
     ox, oy = [], []
     for i in range(0, len(graph)):
         for j in range(0, len(graph[i])):
@@ -213,10 +236,9 @@
     plt.plot(sx, sy, "og")
     plt.plot(gx, gy, "xb")
 
+    # Starting of Main()
+    last = np.array([sx, sy])
     dstar = DStarLite(graph, sx, sy, gx, gy)
-
-    last = dstar.start
-    last = ScanAndUpdate(dstar, last)
     dstar.ComputeShortestPath()
     while np.sum(np.abs(dstar.start - dstar.goal)) != 0:
         s_list = dstar.succ(dstar.start)
@@ -226,10 +248,13 @@
             if dstar.cost(dstar.start, s) + dstar.g[s[0], s[1]] < min_s:
                 min_s = dstar.cost(dstar.start, s) + dstar.g[s[0], s[1]]
                 temp = s
+        if min_s == np.inf:
+            print("no path")
         dstar.start = temp.copy()
         # print(dstar.start[0], dstar.start[1])
         plt.plot(dstar.start[0], dstar.start[1], '.b')
-        last = ScanAndUpdate(dstar, last)
+        plt.pause(0.1)
+        ScanAndUpdate(dstar, last)
         plt.pause(0.1)
     print("Goal Reached")
 
Index: D_Star_Lite.ipynb
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\r\n  \"nbformat\": 4,\r\n  \"nbformat_minor\": 0,\r\n  \"metadata\": {\r\n    \"colab\": {\r\n      \"name\": \"D Star Lite.ipynb\",\r\n      \"provenance\": [],\r\n      \"collapsed_sections\": [],\r\n      \"authorship_tag\": \"ABX9TyOBIkCxn6AeaI3nA+dEtC3I\",\r\n      \"include_colab_link\": true\r\n    },\r\n    \"kernelspec\": {\r\n      \"name\": \"python3\",\r\n      \"display_name\": \"Python 3\"\r\n    }\r\n  },\r\n  \"cells\": [\r\n    {\r\n      \"cell_type\": \"markdown\",\r\n      \"metadata\": {\r\n        \"id\": \"view-in-github\",\r\n        \"colab_type\": \"text\"\r\n      },\r\n      \"source\": [\r\n        \"<a href=\\\"https://colab.research.google.com/github/overtunned/DStar-Lite/blob/main/D_Star_Lite.ipynb\\\" target=\\\"_parent\\\"><img src=\\\"https://colab.research.google.com/assets/colab-badge.svg\\\" alt=\\\"Open In Colab\\\"/></a>\"\r\n      ]\r\n    },\r\n    {\r\n      \"cell_type\": \"code\",\r\n      \"metadata\": {\r\n        \"id\": \"GQ18Kd5F3uKe\",\r\n        \"colab\": {\r\n          \"base_uri\": \"https://localhost:8080/\"\r\n        },\r\n        \"outputId\": \"3cede425-6db4-4c3e-b19a-841a697f5aa3\"\r\n      },\r\n      \"source\": [\r\n        \"!pip install pygame\"\r\n      ],\r\n      \"execution_count\": 25,\r\n      \"outputs\": [\r\n        {\r\n          \"output_type\": \"stream\",\r\n          \"text\": [\r\n            \"Requirement already satisfied: pygame in /usr/local/lib/python3.6/dist-packages (2.0.0)\\n\"\r\n          ],\r\n          \"name\": \"stdout\"\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"cell_type\": \"code\",\r\n      \"metadata\": {\r\n        \"id\": \"BsazihNedhAa\"\r\n      },\r\n      \"source\": [\r\n        \"import os\\r\\n\",\r\n        \"os.environ[\\\"SDL_VIDEODRIVER\\\"] = \\\"dummy\\\"\"\r\n      ],\r\n      \"execution_count\": 26,\r\n      \"outputs\": []\r\n    },\r\n    {\r\n      \"cell_type\": \"code\",\r\n      \"metadata\": {\r\n        \"id\": \"fO_8G5InaABZ\"\r\n      },\r\n      \"source\": [\r\n        \"def stateNameToCoords(name):\\r\\n\",\r\n        \"    return [int(name.split('x')[1].split('y')[0]), int(name.split('x')[1].split('y')[1])]\"\r\n      ],\r\n      \"execution_count\": 27,\r\n      \"outputs\": []\r\n    },\r\n    {\r\n      \"cell_type\": \"code\",\r\n      \"metadata\": {\r\n        \"id\": \"wsMzeXaabDDr\"\r\n      },\r\n      \"source\": [\r\n        \"class GridWorld(Graph):\\r\\n\",\r\n        \"    def __init__(self, x_dim, y_dim, connect8=True):\\r\\n\",\r\n        \"        self.x_dim = x_dim\\r\\n\",\r\n        \"        self.y_dim = y_dim\\r\\n\",\r\n        \"        # First make an element for each row (height of grid)\\r\\n\",\r\n        \"        self.cells = [0] * y_dim\\r\\n\",\r\n        \"        # Go through each element and replace with row (width of grid)\\r\\n\",\r\n        \"        for i in range(y_dim):\\r\\n\",\r\n        \"            self.cells[i] = [0] * x_dim\\r\\n\",\r\n        \"        # will this be an 8-connected graph or 4-connected?\\r\\n\",\r\n        \"        self.connect8 = connect8\\r\\n\",\r\n        \"        self.graph = {}\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"        self.generateGraphFromGrid()\\r\\n\",\r\n        \"        # self.printGrid()\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    def __str__(self):\\r\\n\",\r\n        \"        msg = 'Graph:'\\r\\n\",\r\n        \"        for i in self.graph:\\r\\n\",\r\n        \"            msg += '\\\\n  node: ' + i + ' g: ' + \\\\\\r\\n\",\r\n        \"                str(self.graph[i].g) + ' rhs: ' + str(self.graph[i].rhs) + \\\\\\r\\n\",\r\n        \"                ' neighbors: ' + str(self.graph[i].children)\\r\\n\",\r\n        \"        return msg\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    def __repr__(self):\\r\\n\",\r\n        \"        return self.__str__()\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    def printGrid(self):\\r\\n\",\r\n        \"        print('** GridWorld **')\\r\\n\",\r\n        \"        for row in self.cells:\\r\\n\",\r\n        \"            print(row)\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    def printGValues(self):\\r\\n\",\r\n        \"        for j in range(self.y_dim):\\r\\n\",\r\n        \"            str_msg = \\\"\\\"\\r\\n\",\r\n        \"            for i in range(self.x_dim):\\r\\n\",\r\n        \"                node_id = 'x' + str(i) + 'y' + str(j)\\r\\n\",\r\n        \"                node = self.graph[node_id]\\r\\n\",\r\n        \"                if node.g == float('inf'):\\r\\n\",\r\n        \"                    str_msg += ' - '\\r\\n\",\r\n        \"                else:\\r\\n\",\r\n        \"                    str_msg += ' ' + str(node.g) + ' '\\r\\n\",\r\n        \"            print(str_msg)\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    def generateGraphFromGrid(self):\\r\\n\",\r\n        \"        edge = 1\\r\\n\",\r\n        \"        for i in range(len(self.cells)):\\r\\n\",\r\n        \"            row = self.cells[i]\\r\\n\",\r\n        \"            for j in range(len(row)):\\r\\n\",\r\n        \"                # print('graph node ' + str(i) + ',' + str(j))\\r\\n\",\r\n        \"                node = Node('x' + str(i) + 'y' + str(j))\\r\\n\",\r\n        \"                if i > 0:  # not top row\\r\\n\",\r\n        \"                    node.parents['x' + str(i - 1) + 'y' + str(j)] = edge\\r\\n\",\r\n        \"                    node.children['x' + str(i - 1) + 'y' + str(j)] = edge\\r\\n\",\r\n        \"                if i + 1 < self.y_dim:  # not bottom row\\r\\n\",\r\n        \"                    node.parents['x' + str(i + 1) + 'y' + str(j)] = edge\\r\\n\",\r\n        \"                    node.children['x' + str(i + 1) + 'y' + str(j)] = edge\\r\\n\",\r\n        \"                if j > 0:  # not left col\\r\\n\",\r\n        \"                    node.parents['x' + str(i) + 'y' + str(j - 1)] = edge\\r\\n\",\r\n        \"                    node.children['x' + str(i) + 'y' + str(j - 1)] = edge\\r\\n\",\r\n        \"                if j + 1 < self.x_dim:  # not right col\\r\\n\",\r\n        \"                    node.parents['x' + str(i) + 'y' + str(j + 1)] = edge\\r\\n\",\r\n        \"                    node.children['x' + str(i) + 'y' + str(j + 1)] = edge\\r\\n\",\r\n        \"                self.graph['x' + str(i) + 'y' + str(j)] = node\\r\\n\"\r\n      ],\r\n      \"execution_count\": 28,\r\n      \"outputs\": []\r\n    },\r\n    {\r\n      \"cell_type\": \"code\",\r\n      \"metadata\": {\r\n        \"id\": \"oS4LM6-KbDMW\"\r\n      },\r\n      \"source\": [\r\n        \"class Node:\\r\\n\",\r\n        \"    def __init__(self, id):\\r\\n\",\r\n        \"        self.id = id\\r\\n\",\r\n        \"        # dictionary of parent node ID's\\r\\n\",\r\n        \"        # key = id of parent\\r\\n\",\r\n        \"        # value = (edge cost,)\\r\\n\",\r\n        \"        self.parents = {}\\r\\n\",\r\n        \"        # dictionary of children node ID's\\r\\n\",\r\n        \"        # key = id of child\\r\\n\",\r\n        \"        # value = (edge cost,)\\r\\n\",\r\n        \"        self.children = {}\\r\\n\",\r\n        \"        # g approximation\\r\\n\",\r\n        \"        self.g = float('inf')\\r\\n\",\r\n        \"        # rhs value\\r\\n\",\r\n        \"        self.rhs = float('inf')\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    def __str__(self):\\r\\n\",\r\n        \"        return 'Node: ' + self.id + ' g: ' + str(self.g) + ' rhs: ' + str(self.rhs)\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    def __repr__(self):\\r\\n\",\r\n        \"        return self.__str__()\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    def update_parents(self, parents):\\r\\n\",\r\n        \"        self.parents = parents\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"class Graph:\\r\\n\",\r\n        \"    def __init__(self):\\r\\n\",\r\n        \"        self.graph = {}\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    def __str__(self):\\r\\n\",\r\n        \"        msg = 'Graph:'\\r\\n\",\r\n        \"        for i in self.graph:\\r\\n\",\r\n        \"            msg += '\\\\n  node: ' + i + ' g: ' + \\\\\\r\\n\",\r\n        \"                str(self.graph[i].g) + ' rhs: ' + str(self.graph[i].rhs)\\r\\n\",\r\n        \"        return msg\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    def __repr__(self):\\r\\n\",\r\n        \"        return self.__str__()\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    def setStart(self, id):\\r\\n\",\r\n        \"        if(self.graph[id]):\\r\\n\",\r\n        \"            self.start = id\\r\\n\",\r\n        \"        else:\\r\\n\",\r\n        \"            raise ValueError('start id not in graph')\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    def setGoal(self, id):\\r\\n\",\r\n        \"        if(self.graph[id]):\\r\\n\",\r\n        \"            self.goal = id\\r\\n\",\r\n        \"        else:\\r\\n\",\r\n        \"            raise ValueError('goal id not in graph')\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"def addNodeToGraph(graph, id, neighbors, edge=1):\\r\\n\",\r\n        \"    node = Node(id)\\r\\n\",\r\n        \"    for i in neighbors:\\r\\n\",\r\n        \"        # print(i)\\r\\n\",\r\n        \"        node.parents[i] = edge\\r\\n\",\r\n        \"        node.children[i] = edge\\r\\n\",\r\n        \"    graph[id] = node\\r\\n\",\r\n        \"    return graph\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"def makeGraph():\\r\\n\",\r\n        \"    graph = {}\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    # 8-connected graph (w diagonals)\\r\\n\",\r\n        \"    # Impossible to find path - 2 obstacles in middle\\r\\n\",\r\n        \"    # graph = addNodeToGraph(graph, 'x1y1', ['x1y2', 'x2y1', 'x2y2'])\\r\\n\",\r\n        \"    # graph = addNodeToGraph(\\r\\n\",\r\n        \"    #     graph, 'x2y1', ['x1y1', 'x1y2', 'x3y1', 'x2y2', 'x3y2'], float('inf'))\\r\\n\",\r\n        \"    # graph = addNodeToGraph(graph, 'x1y2', ['x1y1', 'x2y1', 'x2y2'])\\r\\n\",\r\n        \"    # graph = addNodeToGraph(\\r\\n\",\r\n        \"    #     graph, 'x2y2', ['x1y1', 'x1y2', 'x3y1', 'x2y1', 'x3y2'], float('inf'))\\r\\n\",\r\n        \"    # graph = addNodeToGraph(graph, 'x3y1', ['x3y2', 'x2y1', 'x2y2'])\\r\\n\",\r\n        \"    # graph = addNodeToGraph(graph, 'x3y2', ['x3y1', 'x2y1', 'x2y2'])\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    # 8-connected graph (w diagonals)\\r\\n\",\r\n        \"    # Impossible to find path - 2 obstacles in middle\\r\\n\",\r\n        \"    # graph = addNodeToGraph(graph, 'x1y1', ['x1y2', 'x2y1', 'x2y2'])\\r\\n\",\r\n        \"    # graph = addNodeToGraph(\\r\\n\",\r\n        \"    #     graph, 'x2y1', ['x1y1', 'x1y2', 'x3y1', 'x2y2', 'x3y2'], float('inf'))\\r\\n\",\r\n        \"    # graph = addNodeToGraph(graph, 'x1y2', ['x1y1', 'x2y1', 'x2y2'])\\r\\n\",\r\n        \"    # graph = addNodeToGraph(\\r\\n\",\r\n        \"    #     graph, 'x2y2', ['x1y1', 'x1y2', 'x3y1', 'x2y1', 'x3y2'])\\r\\n\",\r\n        \"    # graph = addNodeToGraph(graph, 'x3y1', ['x3y2', 'x2y1', 'x2y2'])\\r\\n\",\r\n        \"    # graph = addNodeToGraph(graph, 'x3y2', ['x3y1', 'x2y1', 'x2y2'])\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    # 4-connected graph (w/out diagonals)\\r\\n\",\r\n        \"    graph = addNodeToGraph(graph, 'x1y1', ['x1y2', 'x2y1'])\\r\\n\",\r\n        \"    graph = addNodeToGraph(graph, 'x2y1', ['x1y1', 'x3y1', 'x2y2'])\\r\\n\",\r\n        \"    graph = addNodeToGraph(graph, 'x1y2', ['x1y1', 'x2y2'])\\r\\n\",\r\n        \"    graph = addNodeToGraph(graph, 'x2y2', ['x1y2', 'x2y1', 'x3y2'])\\r\\n\",\r\n        \"    graph = addNodeToGraph(graph, 'x3y1', ['x3y2', 'x2y1'])\\r\\n\",\r\n        \"    graph = addNodeToGraph(graph, 'x3y2', ['x3y1', 'x2y2'])\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    g = GridWorld(X_DIM, Y_DIM)\\r\\n\",\r\n        \"    # g.graph = graph\\r\\n\",\r\n        \"    # print(g)\\r\\n\",\r\n        \"    return g\\r\\n\"\r\n      ],\r\n      \"execution_count\": 29,\r\n      \"outputs\": []\r\n    },\r\n    {\r\n      \"cell_type\": \"code\",\r\n      \"metadata\": {\r\n        \"id\": \"2wNZ8swFbDPB\"\r\n      },\r\n      \"source\": [\r\n        \"import heapq\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"def topKey(queue):\\r\\n\",\r\n        \"    queue.sort()\\r\\n\",\r\n        \"    # print(queue)\\r\\n\",\r\n        \"    if len(queue) > 0:\\r\\n\",\r\n        \"        return queue[0][:2]\\r\\n\",\r\n        \"    else:\\r\\n\",\r\n        \"        # print('empty queue!')\\r\\n\",\r\n        \"        return (float('inf'), float('inf'))\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"def heuristic_from_s(graph, id, s):\\r\\n\",\r\n        \"    x_distance = abs(int(id.split('x')[1][0]) - int(s.split('x')[1][0]))\\r\\n\",\r\n        \"    y_distance = abs(int(id.split('y')[1][0]) - int(s.split('y')[1][0]))\\r\\n\",\r\n        \"    return max(x_distance, y_distance)\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"def calculateKey(graph, id, s_current, k_m):\\r\\n\",\r\n        \"    return (min(graph.graph[id].g, graph.graph[id].rhs) + heuristic_from_s(graph, id, s_current) + k_m, min(graph.graph[id].g, graph.graph[id].rhs))\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"def updateVertex(graph, queue, id, s_current, k_m):\\r\\n\",\r\n        \"    s_goal = graph.goal\\r\\n\",\r\n        \"    if id != s_goal:\\r\\n\",\r\n        \"        min_rhs = float('inf')\\r\\n\",\r\n        \"        for i in graph.graph[id].children:\\r\\n\",\r\n        \"            min_rhs = min(\\r\\n\",\r\n        \"                min_rhs, graph.graph[i].g + graph.graph[id].children[i])\\r\\n\",\r\n        \"        graph.graph[id].rhs = min_rhs\\r\\n\",\r\n        \"    id_in_queue = [item for item in queue if id in item]\\r\\n\",\r\n        \"    if id_in_queue != []:\\r\\n\",\r\n        \"        if len(id_in_queue) != 1:\\r\\n\",\r\n        \"            raise ValueError('more than one ' + id + ' in the queue!')\\r\\n\",\r\n        \"        queue.remove(id_in_queue[0])\\r\\n\",\r\n        \"    if graph.graph[id].rhs != graph.graph[id].g:\\r\\n\",\r\n        \"        heapq.heappush(queue, calculateKey(graph, id, s_current, k_m) + (id,))\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"def computeShortestPath(graph, queue, s_start, k_m):\\r\\n\",\r\n        \"    while (graph.graph[s_start].rhs != graph.graph[s_start].g) or (topKey(queue) < calculateKey(graph, s_start, s_start, k_m)):\\r\\n\",\r\n        \"        # print(graph.graph[s_start])\\r\\n\",\r\n        \"        # print('topKey')\\r\\n\",\r\n        \"        # print(topKey(queue))\\r\\n\",\r\n        \"        # print('calculateKey')\\r\\n\",\r\n        \"        # print(calculateKey(graph, s_start, 0))\\r\\n\",\r\n        \"        k_old = topKey(queue)\\r\\n\",\r\n        \"        u = heapq.heappop(queue)[2]\\r\\n\",\r\n        \"        if k_old < calculateKey(graph, u, s_start, k_m):\\r\\n\",\r\n        \"            heapq.heappush(queue, calculateKey(graph, u, s_start, k_m) + (u,))\\r\\n\",\r\n        \"        elif graph.graph[u].g > graph.graph[u].rhs:\\r\\n\",\r\n        \"            graph.graph[u].g = graph.graph[u].rhs\\r\\n\",\r\n        \"            for i in graph.graph[u].parents:\\r\\n\",\r\n        \"                updateVertex(graph, queue, i, s_start, k_m)\\r\\n\",\r\n        \"        else:\\r\\n\",\r\n        \"            graph.graph[u].g = float('inf')\\r\\n\",\r\n        \"            updateVertex(graph, queue, u, s_start, k_m)\\r\\n\",\r\n        \"            for i in graph.graph[u].parents:\\r\\n\",\r\n        \"                updateVertex(graph, queue, i, s_start, k_m)\\r\\n\",\r\n        \"        # graph.printGValues()\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"def nextInShortestPath(graph, s_current):\\r\\n\",\r\n        \"    min_rhs = float('inf')\\r\\n\",\r\n        \"    s_next = None\\r\\n\",\r\n        \"    if graph.graph[s_current].rhs == float('inf'):\\r\\n\",\r\n        \"        print('You are done stuck')\\r\\n\",\r\n        \"    else:\\r\\n\",\r\n        \"        for i in graph.graph[s_current].children:\\r\\n\",\r\n        \"            # print(i)\\r\\n\",\r\n        \"            child_cost = graph.graph[i].g + graph.graph[s_current].children[i]\\r\\n\",\r\n        \"            # print(child_cost)\\r\\n\",\r\n        \"            if (child_cost) < min_rhs:\\r\\n\",\r\n        \"                min_rhs = child_cost\\r\\n\",\r\n        \"                s_next = i\\r\\n\",\r\n        \"        if s_next:\\r\\n\",\r\n        \"            return s_next\\r\\n\",\r\n        \"        else:\\r\\n\",\r\n        \"            raise ValueError('could not find child for transition!')\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"def scanForObstacles(graph, queue, s_current, scan_range, k_m):\\r\\n\",\r\n        \"    states_to_update = {}\\r\\n\",\r\n        \"    range_checked = 0\\r\\n\",\r\n        \"    if scan_range >= 1:\\r\\n\",\r\n        \"        for neighbor in graph.graph[s_current].children:\\r\\n\",\r\n        \"            neighbor_coords = stateNameToCoords(neighbor)\\r\\n\",\r\n        \"            states_to_update[neighbor] = graph.cells[neighbor_coords[1]\\r\\n\",\r\n        \"                                                     ][neighbor_coords[0]]\\r\\n\",\r\n        \"        range_checked = 1\\r\\n\",\r\n        \"    # print(states_to_update)\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    while range_checked < scan_range:\\r\\n\",\r\n        \"        new_set = {}\\r\\n\",\r\n        \"        for state in states_to_update:\\r\\n\",\r\n        \"            new_set[state] = states_to_update[state]\\r\\n\",\r\n        \"            for neighbor in graph.graph[state].children:\\r\\n\",\r\n        \"                if neighbor not in new_set:\\r\\n\",\r\n        \"                    neighbor_coords = stateNameToCoords(neighbor)\\r\\n\",\r\n        \"                    new_set[neighbor] = graph.cells[neighbor_coords[1]\\r\\n\",\r\n        \"                                                    ][neighbor_coords[0]]\\r\\n\",\r\n        \"        range_checked += 1\\r\\n\",\r\n        \"        states_to_update = new_set\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    new_obstacle = False\\r\\n\",\r\n        \"    for state in states_to_update:\\r\\n\",\r\n        \"        if states_to_update[state] < 0:  # found cell with obstacle\\r\\n\",\r\n        \"            # print('found obstacle in ', state)\\r\\n\",\r\n        \"            for neighbor in graph.graph[state].children:\\r\\n\",\r\n        \"                # first time to observe this obstacle where one wasn't before\\r\\n\",\r\n        \"                if(graph.graph[state].children[neighbor] != float('inf')):\\r\\n\",\r\n        \"                    neighbor_coords = stateNameToCoords(state)\\r\\n\",\r\n        \"                    graph.cells[neighbor_coords[1]][neighbor_coords[0]] = -2\\r\\n\",\r\n        \"                    graph.graph[neighbor].children[state] = float('inf')\\r\\n\",\r\n        \"                    graph.graph[state].children[neighbor] = float('inf')\\r\\n\",\r\n        \"                    updateVertex(graph, queue, state, s_current, k_m)\\r\\n\",\r\n        \"                    new_obstacle = True\\r\\n\",\r\n        \"        # elif states_to_update[state] == 0: #cell without obstacle\\r\\n\",\r\n        \"            # for neighbor in graph.graph[state].children:\\r\\n\",\r\n        \"                # if(graph.graph[state].children[neighbor] != float('inf')):\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    # print(graph)\\r\\n\",\r\n        \"    return new_obstacle\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"def moveAndRescan(graph, queue, s_current, scan_range, k_m):\\r\\n\",\r\n        \"    if(s_current == graph.goal):\\r\\n\",\r\n        \"        return 'goal', k_m\\r\\n\",\r\n        \"    else:\\r\\n\",\r\n        \"        s_last = s_current\\r\\n\",\r\n        \"        s_new = nextInShortestPath(graph, s_current)\\r\\n\",\r\n        \"        new_coords = stateNameToCoords(s_new)\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"        if(graph.cells[new_coords[1]][new_coords[0]] == -1):  # just ran into new obstacle\\r\\n\",\r\n        \"            s_new = s_current  # need to hold tight and scan/replan first\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"        results = scanForObstacles(graph, queue, s_new, scan_range, k_m)\\r\\n\",\r\n        \"        # print(graph)\\r\\n\",\r\n        \"        k_m += heuristic_from_s(graph, s_last, s_new)\\r\\n\",\r\n        \"        computeShortestPath(graph, queue, s_current, k_m)\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"        return s_new, k_m\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"def initDStarLite(graph, queue, s_start, s_goal, k_m):\\r\\n\",\r\n        \"    graph.graph[s_goal].rhs = 0\\r\\n\",\r\n        \"    heapq.heappush(queue, calculateKey(\\r\\n\",\r\n        \"        graph, s_goal, s_start, k_m) + (s_goal,))\\r\\n\",\r\n        \"    computeShortestPath(graph, queue, s_start, k_m)\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    return (graph, queue, k_m)\\r\\n\"\r\n      ],\r\n      \"execution_count\": 30,\r\n      \"outputs\": []\r\n    },\r\n    {\r\n      \"cell_type\": \"code\",\r\n      \"metadata\": {\r\n        \"id\": \"jTTUtMelaNgr\"\r\n      },\r\n      \"source\": [\r\n        \"import heapq\\r\\n\",\r\n        \"import pygame\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"# Define some colors\\r\\n\",\r\n        \"BLACK = (0, 0, 0)\\r\\n\",\r\n        \"WHITE = (255, 255, 255)\\r\\n\",\r\n        \"GREEN = (0, 255, 0)\\r\\n\",\r\n        \"RED = (255, 0, 0)\\r\\n\",\r\n        \"GRAY1 = (145, 145, 102)\\r\\n\",\r\n        \"GRAY2 = (77, 77, 51)\\r\\n\",\r\n        \"BLUE = (0, 0, 80)\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"colors = {\\r\\n\",\r\n        \"    0: WHITE,\\r\\n\",\r\n        \"    1: GREEN,\\r\\n\",\r\n        \"    -1: GRAY1,\\r\\n\",\r\n        \"    -2: GRAY2\\r\\n\",\r\n        \"}\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"# This sets the WIDTH and HEIGHT of each grid location\\r\\n\",\r\n        \"WIDTH = 40\\r\\n\",\r\n        \"HEIGHT = 40\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"# This sets the margin between each cell\\r\\n\",\r\n        \"MARGIN = 5\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"# Create a 2 dimensional array. A two dimensional\\r\\n\",\r\n        \"# array is simply a list of lists.\\r\\n\",\r\n        \"grid = []\\r\\n\",\r\n        \"for row in range(10):\\r\\n\",\r\n        \"    # Add an empty array that will hold each cell\\r\\n\",\r\n        \"    # in this row\\r\\n\",\r\n        \"    grid.append([])\\r\\n\",\r\n        \"    for column in range(10):\\r\\n\",\r\n        \"        grid[row].append(0)  # Append a cell\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"# Set row 1, cell 5 to one. (Remember rows and\\r\\n\",\r\n        \"# column numbers start at zero.)\\r\\n\",\r\n        \"grid[1][5] = 1\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"# Initialize pygame\\r\\n\",\r\n        \"pygame.init()\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"X_DIM = 12\\r\\n\",\r\n        \"Y_DIM = 12\\r\\n\",\r\n        \"VIEWING_RANGE = 3\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"# Set the HEIGHT and WIDTH of the screen\\r\\n\",\r\n        \"WINDOW_SIZE = [(WIDTH + MARGIN) * X_DIM + MARGIN,\\r\\n\",\r\n        \"               (HEIGHT + MARGIN) * Y_DIM + MARGIN]\\r\\n\",\r\n        \"screen = pygame.display.set_mode(WINDOW_SIZE)\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"# Set title of screen\\r\\n\",\r\n        \"pygame.display.set_caption(\\\"D* Lite Path Planning\\\")\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"# Loop until the user clicks the close button.\\r\\n\",\r\n        \"done = False\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"# Used to manage how fast the screen updates\\r\\n\",\r\n        \"clock = pygame.time.Clock()\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"if __name__ == \\\"__main__\\\":\\r\\n\",\r\n        \"    graph = GridWorld(X_DIM, Y_DIM)\\r\\n\",\r\n        \"    s_start = 'x1y2'\\r\\n\",\r\n        \"    s_goal = 'x5y4'\\r\\n\",\r\n        \"    goal_coords = stateNameToCoords(s_goal)\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    graph.setStart(s_start)\\r\\n\",\r\n        \"    graph.setGoal(s_goal)\\r\\n\",\r\n        \"    k_m = 0\\r\\n\",\r\n        \"    s_last = s_start\\r\\n\",\r\n        \"    queue = []\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    graph, queue, k_m = initDStarLite(graph, queue, s_start, s_goal, k_m)\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    s_current = s_start\\r\\n\",\r\n        \"    pos_coords = stateNameToCoords(s_current)\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    basicfont = pygame.font.SysFont('Comic Sans MS', 36)\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    # -------- Main Program Loop -----------\\r\\n\",\r\n        \"    while not done:\\r\\n\",\r\n        \"        for event in pygame.event.get():  # User did something\\r\\n\",\r\n        \"            if event.type == pygame.QUIT:  # If user clicked close\\r\\n\",\r\n        \"                done = True  # Flag that we are done so we exit this loop\\r\\n\",\r\n        \"            elif event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:\\r\\n\",\r\n        \"                # print('space bar! call next action')\\r\\n\",\r\n        \"                s_new, k_m = moveAndRescan(\\r\\n\",\r\n        \"                    graph, queue, s_current, VIEWING_RANGE, k_m)\\r\\n\",\r\n        \"                if s_new == 'goal':\\r\\n\",\r\n        \"                    print('Goal Reached!')\\r\\n\",\r\n        \"                    done = True\\r\\n\",\r\n        \"                else:\\r\\n\",\r\n        \"                    # print('setting s_current to ', s_new)\\r\\n\",\r\n        \"                    s_current = s_new\\r\\n\",\r\n        \"                    pos_coords = stateNameToCoords(s_current)\\r\\n\",\r\n        \"                    # print('got pos coords: ', pos_coords)\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"            elif event.type == pygame.MOUSEBUTTONDOWN:\\r\\n\",\r\n        \"                # User clicks the mouse. Get the position\\r\\n\",\r\n        \"                pos = pygame.mouse.get_pos()\\r\\n\",\r\n        \"                # Change the x/y screen coordinates to grid coordinates\\r\\n\",\r\n        \"                column = pos[0] // (WIDTH + MARGIN)\\r\\n\",\r\n        \"                row = pos[1] // (HEIGHT + MARGIN)\\r\\n\",\r\n        \"                # Set that location to one\\r\\n\",\r\n        \"                if(graph.cells[row][column] == 0):\\r\\n\",\r\n        \"                    graph.cells[row][column] = -1\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"        # Set the screen background\\r\\n\",\r\n        \"        screen.fill(BLACK)\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"        # Draw the grid\\r\\n\",\r\n        \"        for row in range(Y_DIM):\\r\\n\",\r\n        \"            for column in range(X_DIM):\\r\\n\",\r\n        \"                color = WHITE\\r\\n\",\r\n        \"                # if grid[row][column] == 1:\\r\\n\",\r\n        \"                #     color = GREEN\\r\\n\",\r\n        \"                pygame.draw.rect(screen, colors[graph.cells[row][column]],\\r\\n\",\r\n        \"                                 [(MARGIN + WIDTH) * column + MARGIN,\\r\\n\",\r\n        \"                                  (MARGIN + HEIGHT) * row + MARGIN, WIDTH, HEIGHT])\\r\\n\",\r\n        \"                node_name = 'x' + str(column) + 'y' + str(row)\\r\\n\",\r\n        \"                if(graph.graph[node_name].g != float('inf')):\\r\\n\",\r\n        \"                    # text = basicfont.render(\\r\\n\",\r\n        \"                    # str(graph.graph[node_name].g), True, (0, 0, 200), (255,\\r\\n\",\r\n        \"                    # 255, 255))\\r\\n\",\r\n        \"                    text = basicfont.render(\\r\\n\",\r\n        \"                        str(graph.graph[node_name].g), True, (0, 0, 200))\\r\\n\",\r\n        \"                    textrect = text.get_rect()\\r\\n\",\r\n        \"                    textrect.centerx = int(\\r\\n\",\r\n        \"                        column * (WIDTH + MARGIN) + WIDTH / 2) + MARGIN\\r\\n\",\r\n        \"                    textrect.centery = int(\\r\\n\",\r\n        \"                        row * (HEIGHT + MARGIN) + HEIGHT / 2) + MARGIN\\r\\n\",\r\n        \"                    screen.blit(text, textrect)\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"        # fill in goal cell with GREEN\\r\\n\",\r\n        \"        pygame.draw.rect(screen, GREEN, [(MARGIN + WIDTH) * goal_coords[0] + MARGIN,\\r\\n\",\r\n        \"                                         (MARGIN + HEIGHT) * goal_coords[1] + MARGIN, WIDTH, HEIGHT])\\r\\n\",\r\n        \"        # print('drawing robot pos_coords: ', pos_coords)\\r\\n\",\r\n        \"        # draw moving robot, based on pos_coords\\r\\n\",\r\n        \"        robot_center = [int(pos_coords[0] * (WIDTH + MARGIN) + WIDTH / 2) +\\r\\n\",\r\n        \"                        MARGIN, int(pos_coords[1] * (HEIGHT + MARGIN) + HEIGHT / 2) + MARGIN]\\r\\n\",\r\n        \"        pygame.draw.circle(screen, RED, robot_center, int(WIDTH / 2) - 2)\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"        # draw robot viewing range\\r\\n\",\r\n        \"        pygame.draw.rect(\\r\\n\",\r\n        \"            screen, BLUE, [robot_center[0] - VIEWING_RANGE * (WIDTH + MARGIN), robot_center[1] - VIEWING_RANGE * (HEIGHT + MARGIN), 2 * VIEWING_RANGE * (WIDTH + MARGIN), 2 * VIEWING_RANGE * (HEIGHT + MARGIN)], 2)\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"        # Limit to 60 frames per second\\r\\n\",\r\n        \"        clock.tick(20)\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"        # Go ahead and update the screen with what we've drawn.\\r\\n\",\r\n        \"        pygame.display.flip()\\r\\n\",\r\n        \"\\r\\n\",\r\n        \"    # Be IDLE friendly. If you forget this line, the program will 'hang'\\r\\n\",\r\n        \"    # on exit.\\r\\n\",\r\n        \"    pygame.quit()\\r\\n\"\r\n      ],\r\n      \"execution_count\": null,\r\n      \"outputs\": []\r\n    }\r\n  ]\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/D_Star_Lite.ipynb b/D_Star_Lite.ipynb
--- a/D_Star_Lite.ipynb	(revision 4d6daa713219b065fe833c61153c3a22f1c5a250)
+++ b/D_Star_Lite.ipynb	(date 1609954353587)
@@ -1,590 +1,604 @@
 {
-  "nbformat": 4,
-  "nbformat_minor": 0,
-  "metadata": {
-    "colab": {
-      "name": "D Star Lite.ipynb",
-      "provenance": [],
-      "collapsed_sections": [],
-      "authorship_tag": "ABX9TyOBIkCxn6AeaI3nA+dEtC3I",
-      "include_colab_link": true
-    },
-    "kernelspec": {
-      "name": "python3",
-      "display_name": "Python 3"
-    }
-  },
-  "cells": [
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "view-in-github",
-        "colab_type": "text"
-      },
-      "source": [
-        "<a href=\"https://colab.research.google.com/github/overtunned/DStar-Lite/blob/main/D_Star_Lite.ipynb\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "metadata": {
-        "id": "GQ18Kd5F3uKe",
-        "colab": {
-          "base_uri": "https://localhost:8080/"
-        },
-        "outputId": "3cede425-6db4-4c3e-b19a-841a697f5aa3"
-      },
-      "source": [
-        "!pip install pygame"
-      ],
-      "execution_count": 25,
-      "outputs": [
-        {
-          "output_type": "stream",
-          "text": [
-            "Requirement already satisfied: pygame in /usr/local/lib/python3.6/dist-packages (2.0.0)\n"
-          ],
-          "name": "stdout"
-        }
-      ]
-    },
-    {
-      "cell_type": "code",
-      "metadata": {
-        "id": "BsazihNedhAa"
-      },
-      "source": [
-        "import os\r\n",
-        "os.environ[\"SDL_VIDEODRIVER\"] = \"dummy\""
-      ],
-      "execution_count": 26,
-      "outputs": []
-    },
-    {
-      "cell_type": "code",
-      "metadata": {
-        "id": "fO_8G5InaABZ"
-      },
-      "source": [
-        "def stateNameToCoords(name):\r\n",
-        "    return [int(name.split('x')[1].split('y')[0]), int(name.split('x')[1].split('y')[1])]"
-      ],
-      "execution_count": 27,
-      "outputs": []
-    },
-    {
-      "cell_type": "code",
-      "metadata": {
-        "id": "wsMzeXaabDDr"
-      },
-      "source": [
-        "class GridWorld(Graph):\r\n",
-        "    def __init__(self, x_dim, y_dim, connect8=True):\r\n",
-        "        self.x_dim = x_dim\r\n",
-        "        self.y_dim = y_dim\r\n",
-        "        # First make an element for each row (height of grid)\r\n",
-        "        self.cells = [0] * y_dim\r\n",
-        "        # Go through each element and replace with row (width of grid)\r\n",
-        "        for i in range(y_dim):\r\n",
-        "            self.cells[i] = [0] * x_dim\r\n",
-        "        # will this be an 8-connected graph or 4-connected?\r\n",
-        "        self.connect8 = connect8\r\n",
-        "        self.graph = {}\r\n",
-        "\r\n",
-        "        self.generateGraphFromGrid()\r\n",
-        "        # self.printGrid()\r\n",
-        "\r\n",
-        "    def __str__(self):\r\n",
-        "        msg = 'Graph:'\r\n",
-        "        for i in self.graph:\r\n",
-        "            msg += '\\n  node: ' + i + ' g: ' + \\\r\n",
-        "                str(self.graph[i].g) + ' rhs: ' + str(self.graph[i].rhs) + \\\r\n",
-        "                ' neighbors: ' + str(self.graph[i].children)\r\n",
-        "        return msg\r\n",
-        "\r\n",
-        "    def __repr__(self):\r\n",
-        "        return self.__str__()\r\n",
-        "\r\n",
-        "    def printGrid(self):\r\n",
-        "        print('** GridWorld **')\r\n",
-        "        for row in self.cells:\r\n",
-        "            print(row)\r\n",
-        "\r\n",
-        "    def printGValues(self):\r\n",
-        "        for j in range(self.y_dim):\r\n",
-        "            str_msg = \"\"\r\n",
-        "            for i in range(self.x_dim):\r\n",
-        "                node_id = 'x' + str(i) + 'y' + str(j)\r\n",
-        "                node = self.graph[node_id]\r\n",
-        "                if node.g == float('inf'):\r\n",
-        "                    str_msg += ' - '\r\n",
-        "                else:\r\n",
-        "                    str_msg += ' ' + str(node.g) + ' '\r\n",
-        "            print(str_msg)\r\n",
-        "\r\n",
-        "    def generateGraphFromGrid(self):\r\n",
-        "        edge = 1\r\n",
-        "        for i in range(len(self.cells)):\r\n",
-        "            row = self.cells[i]\r\n",
-        "            for j in range(len(row)):\r\n",
-        "                # print('graph node ' + str(i) + ',' + str(j))\r\n",
-        "                node = Node('x' + str(i) + 'y' + str(j))\r\n",
-        "                if i > 0:  # not top row\r\n",
-        "                    node.parents['x' + str(i - 1) + 'y' + str(j)] = edge\r\n",
-        "                    node.children['x' + str(i - 1) + 'y' + str(j)] = edge\r\n",
-        "                if i + 1 < self.y_dim:  # not bottom row\r\n",
-        "                    node.parents['x' + str(i + 1) + 'y' + str(j)] = edge\r\n",
-        "                    node.children['x' + str(i + 1) + 'y' + str(j)] = edge\r\n",
-        "                if j > 0:  # not left col\r\n",
-        "                    node.parents['x' + str(i) + 'y' + str(j - 1)] = edge\r\n",
-        "                    node.children['x' + str(i) + 'y' + str(j - 1)] = edge\r\n",
-        "                if j + 1 < self.x_dim:  # not right col\r\n",
-        "                    node.parents['x' + str(i) + 'y' + str(j + 1)] = edge\r\n",
-        "                    node.children['x' + str(i) + 'y' + str(j + 1)] = edge\r\n",
-        "                self.graph['x' + str(i) + 'y' + str(j)] = node\r\n"
-      ],
-      "execution_count": 28,
-      "outputs": []
-    },
-    {
-      "cell_type": "code",
-      "metadata": {
-        "id": "oS4LM6-KbDMW"
-      },
-      "source": [
-        "class Node:\r\n",
-        "    def __init__(self, id):\r\n",
-        "        self.id = id\r\n",
-        "        # dictionary of parent node ID's\r\n",
-        "        # key = id of parent\r\n",
-        "        # value = (edge cost,)\r\n",
-        "        self.parents = {}\r\n",
-        "        # dictionary of children node ID's\r\n",
-        "        # key = id of child\r\n",
-        "        # value = (edge cost,)\r\n",
-        "        self.children = {}\r\n",
-        "        # g approximation\r\n",
-        "        self.g = float('inf')\r\n",
-        "        # rhs value\r\n",
-        "        self.rhs = float('inf')\r\n",
-        "\r\n",
-        "    def __str__(self):\r\n",
-        "        return 'Node: ' + self.id + ' g: ' + str(self.g) + ' rhs: ' + str(self.rhs)\r\n",
-        "\r\n",
-        "    def __repr__(self):\r\n",
-        "        return self.__str__()\r\n",
-        "\r\n",
-        "    def update_parents(self, parents):\r\n",
-        "        self.parents = parents\r\n",
-        "\r\n",
-        "\r\n",
-        "class Graph:\r\n",
-        "    def __init__(self):\r\n",
-        "        self.graph = {}\r\n",
-        "\r\n",
-        "    def __str__(self):\r\n",
-        "        msg = 'Graph:'\r\n",
-        "        for i in self.graph:\r\n",
-        "            msg += '\\n  node: ' + i + ' g: ' + \\\r\n",
-        "                str(self.graph[i].g) + ' rhs: ' + str(self.graph[i].rhs)\r\n",
-        "        return msg\r\n",
-        "\r\n",
-        "    def __repr__(self):\r\n",
-        "        return self.__str__()\r\n",
-        "\r\n",
-        "    def setStart(self, id):\r\n",
-        "        if(self.graph[id]):\r\n",
-        "            self.start = id\r\n",
-        "        else:\r\n",
-        "            raise ValueError('start id not in graph')\r\n",
-        "\r\n",
-        "    def setGoal(self, id):\r\n",
-        "        if(self.graph[id]):\r\n",
-        "            self.goal = id\r\n",
-        "        else:\r\n",
-        "            raise ValueError('goal id not in graph')\r\n",
-        "\r\n",
-        "\r\n",
-        "def addNodeToGraph(graph, id, neighbors, edge=1):\r\n",
-        "    node = Node(id)\r\n",
-        "    for i in neighbors:\r\n",
-        "        # print(i)\r\n",
-        "        node.parents[i] = edge\r\n",
-        "        node.children[i] = edge\r\n",
-        "    graph[id] = node\r\n",
-        "    return graph\r\n",
-        "\r\n",
-        "\r\n",
-        "def makeGraph():\r\n",
-        "    graph = {}\r\n",
-        "\r\n",
-        "    # 8-connected graph (w diagonals)\r\n",
-        "    # Impossible to find path - 2 obstacles in middle\r\n",
-        "    # graph = addNodeToGraph(graph, 'x1y1', ['x1y2', 'x2y1', 'x2y2'])\r\n",
-        "    # graph = addNodeToGraph(\r\n",
-        "    #     graph, 'x2y1', ['x1y1', 'x1y2', 'x3y1', 'x2y2', 'x3y2'], float('inf'))\r\n",
-        "    # graph = addNodeToGraph(graph, 'x1y2', ['x1y1', 'x2y1', 'x2y2'])\r\n",
-        "    # graph = addNodeToGraph(\r\n",
-        "    #     graph, 'x2y2', ['x1y1', 'x1y2', 'x3y1', 'x2y1', 'x3y2'], float('inf'))\r\n",
-        "    # graph = addNodeToGraph(graph, 'x3y1', ['x3y2', 'x2y1', 'x2y2'])\r\n",
-        "    # graph = addNodeToGraph(graph, 'x3y2', ['x3y1', 'x2y1', 'x2y2'])\r\n",
-        "\r\n",
-        "    # 8-connected graph (w diagonals)\r\n",
-        "    # Impossible to find path - 2 obstacles in middle\r\n",
-        "    # graph = addNodeToGraph(graph, 'x1y1', ['x1y2', 'x2y1', 'x2y2'])\r\n",
-        "    # graph = addNodeToGraph(\r\n",
-        "    #     graph, 'x2y1', ['x1y1', 'x1y2', 'x3y1', 'x2y2', 'x3y2'], float('inf'))\r\n",
-        "    # graph = addNodeToGraph(graph, 'x1y2', ['x1y1', 'x2y1', 'x2y2'])\r\n",
-        "    # graph = addNodeToGraph(\r\n",
-        "    #     graph, 'x2y2', ['x1y1', 'x1y2', 'x3y1', 'x2y1', 'x3y2'])\r\n",
-        "    # graph = addNodeToGraph(graph, 'x3y1', ['x3y2', 'x2y1', 'x2y2'])\r\n",
-        "    # graph = addNodeToGraph(graph, 'x3y2', ['x3y1', 'x2y1', 'x2y2'])\r\n",
-        "\r\n",
-        "    # 4-connected graph (w/out diagonals)\r\n",
-        "    graph = addNodeToGraph(graph, 'x1y1', ['x1y2', 'x2y1'])\r\n",
-        "    graph = addNodeToGraph(graph, 'x2y1', ['x1y1', 'x3y1', 'x2y2'])\r\n",
-        "    graph = addNodeToGraph(graph, 'x1y2', ['x1y1', 'x2y2'])\r\n",
-        "    graph = addNodeToGraph(graph, 'x2y2', ['x1y2', 'x2y1', 'x3y2'])\r\n",
-        "    graph = addNodeToGraph(graph, 'x3y1', ['x3y2', 'x2y1'])\r\n",
-        "    graph = addNodeToGraph(graph, 'x3y2', ['x3y1', 'x2y2'])\r\n",
-        "\r\n",
-        "    g = GridWorld(X_DIM, Y_DIM)\r\n",
-        "    # g.graph = graph\r\n",
-        "    # print(g)\r\n",
-        "    return g\r\n"
-      ],
-      "execution_count": 29,
-      "outputs": []
-    },
-    {
-      "cell_type": "code",
-      "metadata": {
-        "id": "2wNZ8swFbDPB"
-      },
-      "source": [
-        "import heapq\r\n",
-        "\r\n",
-        "\r\n",
-        "def topKey(queue):\r\n",
-        "    queue.sort()\r\n",
-        "    # print(queue)\r\n",
-        "    if len(queue) > 0:\r\n",
-        "        return queue[0][:2]\r\n",
-        "    else:\r\n",
-        "        # print('empty queue!')\r\n",
-        "        return (float('inf'), float('inf'))\r\n",
-        "\r\n",
-        "\r\n",
-        "def heuristic_from_s(graph, id, s):\r\n",
-        "    x_distance = abs(int(id.split('x')[1][0]) - int(s.split('x')[1][0]))\r\n",
-        "    y_distance = abs(int(id.split('y')[1][0]) - int(s.split('y')[1][0]))\r\n",
-        "    return max(x_distance, y_distance)\r\n",
-        "\r\n",
-        "\r\n",
-        "def calculateKey(graph, id, s_current, k_m):\r\n",
-        "    return (min(graph.graph[id].g, graph.graph[id].rhs) + heuristic_from_s(graph, id, s_current) + k_m, min(graph.graph[id].g, graph.graph[id].rhs))\r\n",
-        "\r\n",
-        "\r\n",
-        "def updateVertex(graph, queue, id, s_current, k_m):\r\n",
-        "    s_goal = graph.goal\r\n",
-        "    if id != s_goal:\r\n",
-        "        min_rhs = float('inf')\r\n",
-        "        for i in graph.graph[id].children:\r\n",
-        "            min_rhs = min(\r\n",
-        "                min_rhs, graph.graph[i].g + graph.graph[id].children[i])\r\n",
-        "        graph.graph[id].rhs = min_rhs\r\n",
-        "    id_in_queue = [item for item in queue if id in item]\r\n",
-        "    if id_in_queue != []:\r\n",
-        "        if len(id_in_queue) != 1:\r\n",
-        "            raise ValueError('more than one ' + id + ' in the queue!')\r\n",
-        "        queue.remove(id_in_queue[0])\r\n",
-        "    if graph.graph[id].rhs != graph.graph[id].g:\r\n",
-        "        heapq.heappush(queue, calculateKey(graph, id, s_current, k_m) + (id,))\r\n",
-        "\r\n",
-        "\r\n",
-        "def computeShortestPath(graph, queue, s_start, k_m):\r\n",
-        "    while (graph.graph[s_start].rhs != graph.graph[s_start].g) or (topKey(queue) < calculateKey(graph, s_start, s_start, k_m)):\r\n",
-        "        # print(graph.graph[s_start])\r\n",
-        "        # print('topKey')\r\n",
-        "        # print(topKey(queue))\r\n",
-        "        # print('calculateKey')\r\n",
-        "        # print(calculateKey(graph, s_start, 0))\r\n",
-        "        k_old = topKey(queue)\r\n",
-        "        u = heapq.heappop(queue)[2]\r\n",
-        "        if k_old < calculateKey(graph, u, s_start, k_m):\r\n",
-        "            heapq.heappush(queue, calculateKey(graph, u, s_start, k_m) + (u,))\r\n",
-        "        elif graph.graph[u].g > graph.graph[u].rhs:\r\n",
-        "            graph.graph[u].g = graph.graph[u].rhs\r\n",
-        "            for i in graph.graph[u].parents:\r\n",
-        "                updateVertex(graph, queue, i, s_start, k_m)\r\n",
-        "        else:\r\n",
-        "            graph.graph[u].g = float('inf')\r\n",
-        "            updateVertex(graph, queue, u, s_start, k_m)\r\n",
-        "            for i in graph.graph[u].parents:\r\n",
-        "                updateVertex(graph, queue, i, s_start, k_m)\r\n",
-        "        # graph.printGValues()\r\n",
-        "\r\n",
-        "\r\n",
-        "def nextInShortestPath(graph, s_current):\r\n",
-        "    min_rhs = float('inf')\r\n",
-        "    s_next = None\r\n",
-        "    if graph.graph[s_current].rhs == float('inf'):\r\n",
-        "        print('You are done stuck')\r\n",
-        "    else:\r\n",
-        "        for i in graph.graph[s_current].children:\r\n",
-        "            # print(i)\r\n",
-        "            child_cost = graph.graph[i].g + graph.graph[s_current].children[i]\r\n",
-        "            # print(child_cost)\r\n",
-        "            if (child_cost) < min_rhs:\r\n",
-        "                min_rhs = child_cost\r\n",
-        "                s_next = i\r\n",
-        "        if s_next:\r\n",
-        "            return s_next\r\n",
-        "        else:\r\n",
-        "            raise ValueError('could not find child for transition!')\r\n",
-        "\r\n",
-        "\r\n",
-        "def scanForObstacles(graph, queue, s_current, scan_range, k_m):\r\n",
-        "    states_to_update = {}\r\n",
-        "    range_checked = 0\r\n",
-        "    if scan_range >= 1:\r\n",
-        "        for neighbor in graph.graph[s_current].children:\r\n",
-        "            neighbor_coords = stateNameToCoords(neighbor)\r\n",
-        "            states_to_update[neighbor] = graph.cells[neighbor_coords[1]\r\n",
-        "                                                     ][neighbor_coords[0]]\r\n",
-        "        range_checked = 1\r\n",
-        "    # print(states_to_update)\r\n",
-        "\r\n",
-        "    while range_checked < scan_range:\r\n",
-        "        new_set = {}\r\n",
-        "        for state in states_to_update:\r\n",
-        "            new_set[state] = states_to_update[state]\r\n",
-        "            for neighbor in graph.graph[state].children:\r\n",
-        "                if neighbor not in new_set:\r\n",
-        "                    neighbor_coords = stateNameToCoords(neighbor)\r\n",
-        "                    new_set[neighbor] = graph.cells[neighbor_coords[1]\r\n",
-        "                                                    ][neighbor_coords[0]]\r\n",
-        "        range_checked += 1\r\n",
-        "        states_to_update = new_set\r\n",
-        "\r\n",
-        "    new_obstacle = False\r\n",
-        "    for state in states_to_update:\r\n",
-        "        if states_to_update[state] < 0:  # found cell with obstacle\r\n",
-        "            # print('found obstacle in ', state)\r\n",
-        "            for neighbor in graph.graph[state].children:\r\n",
-        "                # first time to observe this obstacle where one wasn't before\r\n",
-        "                if(graph.graph[state].children[neighbor] != float('inf')):\r\n",
-        "                    neighbor_coords = stateNameToCoords(state)\r\n",
-        "                    graph.cells[neighbor_coords[1]][neighbor_coords[0]] = -2\r\n",
-        "                    graph.graph[neighbor].children[state] = float('inf')\r\n",
-        "                    graph.graph[state].children[neighbor] = float('inf')\r\n",
-        "                    updateVertex(graph, queue, state, s_current, k_m)\r\n",
-        "                    new_obstacle = True\r\n",
-        "        # elif states_to_update[state] == 0: #cell without obstacle\r\n",
-        "            # for neighbor in graph.graph[state].children:\r\n",
-        "                # if(graph.graph[state].children[neighbor] != float('inf')):\r\n",
-        "\r\n",
-        "    # print(graph)\r\n",
-        "    return new_obstacle\r\n",
-        "\r\n",
-        "\r\n",
-        "def moveAndRescan(graph, queue, s_current, scan_range, k_m):\r\n",
-        "    if(s_current == graph.goal):\r\n",
-        "        return 'goal', k_m\r\n",
-        "    else:\r\n",
-        "        s_last = s_current\r\n",
-        "        s_new = nextInShortestPath(graph, s_current)\r\n",
-        "        new_coords = stateNameToCoords(s_new)\r\n",
-        "\r\n",
-        "        if(graph.cells[new_coords[1]][new_coords[0]] == -1):  # just ran into new obstacle\r\n",
-        "            s_new = s_current  # need to hold tight and scan/replan first\r\n",
-        "\r\n",
-        "        results = scanForObstacles(graph, queue, s_new, scan_range, k_m)\r\n",
-        "        # print(graph)\r\n",
-        "        k_m += heuristic_from_s(graph, s_last, s_new)\r\n",
-        "        computeShortestPath(graph, queue, s_current, k_m)\r\n",
-        "\r\n",
-        "        return s_new, k_m\r\n",
-        "\r\n",
-        "\r\n",
-        "def initDStarLite(graph, queue, s_start, s_goal, k_m):\r\n",
-        "    graph.graph[s_goal].rhs = 0\r\n",
-        "    heapq.heappush(queue, calculateKey(\r\n",
-        "        graph, s_goal, s_start, k_m) + (s_goal,))\r\n",
-        "    computeShortestPath(graph, queue, s_start, k_m)\r\n",
-        "\r\n",
-        "    return (graph, queue, k_m)\r\n"
-      ],
-      "execution_count": 30,
-      "outputs": []
-    },
-    {
-      "cell_type": "code",
-      "metadata": {
-        "id": "jTTUtMelaNgr"
-      },
-      "source": [
-        "import heapq\r\n",
-        "import pygame\r\n",
-        "\r\n",
-        "\r\n",
-        "# Define some colors\r\n",
-        "BLACK = (0, 0, 0)\r\n",
-        "WHITE = (255, 255, 255)\r\n",
-        "GREEN = (0, 255, 0)\r\n",
-        "RED = (255, 0, 0)\r\n",
-        "GRAY1 = (145, 145, 102)\r\n",
-        "GRAY2 = (77, 77, 51)\r\n",
-        "BLUE = (0, 0, 80)\r\n",
-        "\r\n",
-        "colors = {\r\n",
-        "    0: WHITE,\r\n",
-        "    1: GREEN,\r\n",
-        "    -1: GRAY1,\r\n",
-        "    -2: GRAY2\r\n",
-        "}\r\n",
-        "\r\n",
-        "# This sets the WIDTH and HEIGHT of each grid location\r\n",
-        "WIDTH = 40\r\n",
-        "HEIGHT = 40\r\n",
-        "\r\n",
-        "# This sets the margin between each cell\r\n",
-        "MARGIN = 5\r\n",
-        "\r\n",
-        "# Create a 2 dimensional array. A two dimensional\r\n",
-        "# array is simply a list of lists.\r\n",
-        "grid = []\r\n",
-        "for row in range(10):\r\n",
-        "    # Add an empty array that will hold each cell\r\n",
-        "    # in this row\r\n",
-        "    grid.append([])\r\n",
-        "    for column in range(10):\r\n",
-        "        grid[row].append(0)  # Append a cell\r\n",
-        "\r\n",
-        "# Set row 1, cell 5 to one. (Remember rows and\r\n",
-        "# column numbers start at zero.)\r\n",
-        "grid[1][5] = 1\r\n",
-        "\r\n",
-        "# Initialize pygame\r\n",
-        "pygame.init()\r\n",
-        "\r\n",
-        "X_DIM = 12\r\n",
-        "Y_DIM = 12\r\n",
-        "VIEWING_RANGE = 3\r\n",
-        "\r\n",
-        "\r\n",
-        "# Set the HEIGHT and WIDTH of the screen\r\n",
-        "WINDOW_SIZE = [(WIDTH + MARGIN) * X_DIM + MARGIN,\r\n",
-        "               (HEIGHT + MARGIN) * Y_DIM + MARGIN]\r\n",
-        "screen = pygame.display.set_mode(WINDOW_SIZE)\r\n",
-        "\r\n",
-        "# Set title of screen\r\n",
-        "pygame.display.set_caption(\"D* Lite Path Planning\")\r\n",
-        "\r\n",
-        "# Loop until the user clicks the close button.\r\n",
-        "done = False\r\n",
-        "\r\n",
-        "# Used to manage how fast the screen updates\r\n",
-        "clock = pygame.time.Clock()\r\n",
-        "\r\n",
-        "if __name__ == \"__main__\":\r\n",
-        "    graph = GridWorld(X_DIM, Y_DIM)\r\n",
-        "    s_start = 'x1y2'\r\n",
-        "    s_goal = 'x5y4'\r\n",
-        "    goal_coords = stateNameToCoords(s_goal)\r\n",
-        "\r\n",
-        "    graph.setStart(s_start)\r\n",
-        "    graph.setGoal(s_goal)\r\n",
-        "    k_m = 0\r\n",
-        "    s_last = s_start\r\n",
-        "    queue = []\r\n",
-        "\r\n",
-        "    graph, queue, k_m = initDStarLite(graph, queue, s_start, s_goal, k_m)\r\n",
-        "\r\n",
-        "    s_current = s_start\r\n",
-        "    pos_coords = stateNameToCoords(s_current)\r\n",
-        "\r\n",
-        "    basicfont = pygame.font.SysFont('Comic Sans MS', 36)\r\n",
-        "\r\n",
-        "    # -------- Main Program Loop -----------\r\n",
-        "    while not done:\r\n",
-        "        for event in pygame.event.get():  # User did something\r\n",
-        "            if event.type == pygame.QUIT:  # If user clicked close\r\n",
-        "                done = True  # Flag that we are done so we exit this loop\r\n",
-        "            elif event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:\r\n",
-        "                # print('space bar! call next action')\r\n",
-        "                s_new, k_m = moveAndRescan(\r\n",
-        "                    graph, queue, s_current, VIEWING_RANGE, k_m)\r\n",
-        "                if s_new == 'goal':\r\n",
-        "                    print('Goal Reached!')\r\n",
-        "                    done = True\r\n",
-        "                else:\r\n",
-        "                    # print('setting s_current to ', s_new)\r\n",
-        "                    s_current = s_new\r\n",
-        "                    pos_coords = stateNameToCoords(s_current)\r\n",
-        "                    # print('got pos coords: ', pos_coords)\r\n",
-        "\r\n",
-        "            elif event.type == pygame.MOUSEBUTTONDOWN:\r\n",
-        "                # User clicks the mouse. Get the position\r\n",
-        "                pos = pygame.mouse.get_pos()\r\n",
-        "                # Change the x/y screen coordinates to grid coordinates\r\n",
-        "                column = pos[0] // (WIDTH + MARGIN)\r\n",
-        "                row = pos[1] // (HEIGHT + MARGIN)\r\n",
-        "                # Set that location to one\r\n",
-        "                if(graph.cells[row][column] == 0):\r\n",
-        "                    graph.cells[row][column] = -1\r\n",
-        "\r\n",
-        "        # Set the screen background\r\n",
-        "        screen.fill(BLACK)\r\n",
-        "\r\n",
-        "        # Draw the grid\r\n",
-        "        for row in range(Y_DIM):\r\n",
-        "            for column in range(X_DIM):\r\n",
-        "                color = WHITE\r\n",
-        "                # if grid[row][column] == 1:\r\n",
-        "                #     color = GREEN\r\n",
-        "                pygame.draw.rect(screen, colors[graph.cells[row][column]],\r\n",
-        "                                 [(MARGIN + WIDTH) * column + MARGIN,\r\n",
-        "                                  (MARGIN + HEIGHT) * row + MARGIN, WIDTH, HEIGHT])\r\n",
-        "                node_name = 'x' + str(column) + 'y' + str(row)\r\n",
-        "                if(graph.graph[node_name].g != float('inf')):\r\n",
-        "                    # text = basicfont.render(\r\n",
-        "                    # str(graph.graph[node_name].g), True, (0, 0, 200), (255,\r\n",
-        "                    # 255, 255))\r\n",
-        "                    text = basicfont.render(\r\n",
-        "                        str(graph.graph[node_name].g), True, (0, 0, 200))\r\n",
-        "                    textrect = text.get_rect()\r\n",
-        "                    textrect.centerx = int(\r\n",
-        "                        column * (WIDTH + MARGIN) + WIDTH / 2) + MARGIN\r\n",
-        "                    textrect.centery = int(\r\n",
-        "                        row * (HEIGHT + MARGIN) + HEIGHT / 2) + MARGIN\r\n",
-        "                    screen.blit(text, textrect)\r\n",
-        "\r\n",
-        "        # fill in goal cell with GREEN\r\n",
-        "        pygame.draw.rect(screen, GREEN, [(MARGIN + WIDTH) * goal_coords[0] + MARGIN,\r\n",
-        "                                         (MARGIN + HEIGHT) * goal_coords[1] + MARGIN, WIDTH, HEIGHT])\r\n",
-        "        # print('drawing robot pos_coords: ', pos_coords)\r\n",
-        "        # draw moving robot, based on pos_coords\r\n",
-        "        robot_center = [int(pos_coords[0] * (WIDTH + MARGIN) + WIDTH / 2) +\r\n",
-        "                        MARGIN, int(pos_coords[1] * (HEIGHT + MARGIN) + HEIGHT / 2) + MARGIN]\r\n",
-        "        pygame.draw.circle(screen, RED, robot_center, int(WIDTH / 2) - 2)\r\n",
-        "\r\n",
-        "        # draw robot viewing range\r\n",
-        "        pygame.draw.rect(\r\n",
-        "            screen, BLUE, [robot_center[0] - VIEWING_RANGE * (WIDTH + MARGIN), robot_center[1] - VIEWING_RANGE * (HEIGHT + MARGIN), 2 * VIEWING_RANGE * (WIDTH + MARGIN), 2 * VIEWING_RANGE * (HEIGHT + MARGIN)], 2)\r\n",
-        "\r\n",
-        "        # Limit to 60 frames per second\r\n",
-        "        clock.tick(20)\r\n",
-        "\r\n",
-        "        # Go ahead and update the screen with what we've drawn.\r\n",
-        "        pygame.display.flip()\r\n",
-        "\r\n",
-        "    # Be IDLE friendly. If you forget this line, the program will 'hang'\r\n",
-        "    # on exit.\r\n",
-        "    pygame.quit()\r\n"
-      ],
-      "execution_count": null,
-      "outputs": []
-    }
-  ]
-}
\ No newline at end of file
+ "cells": [
+  {
+   "cell_type": "code",
+   "execution_count": 1,
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "#https://github.com/mdeyo/d-star-lite"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 2,
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "#utils\n",
+    "\n",
+    "def stateNameToCoords(name):\n",
+    "    return [int(name.split('x')[1].split('y')[0]), int(name.split('x')[1].split('y')[1])]\n"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 3,
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "#graph\n",
+    "\n",
+    "class Node:\n",
+    "    def __init__(self, id):\n",
+    "        self.id = id\n",
+    "        # dictionary of parent node ID's\n",
+    "        # key = id of parent\n",
+    "        # value = (edge cost,)\n",
+    "        self.parents = {}\n",
+    "        # dictionary of children node ID's\n",
+    "        # key = id of child\n",
+    "        # value = (edge cost,)\n",
+    "        self.children = {}\n",
+    "        # g approximation\n",
+    "        self.g = float('inf')\n",
+    "        # rhs value\n",
+    "        self.rhs = float('inf')\n",
+    "\n",
+    "    def __str__(self):\n",
+    "        return 'Node: ' + self.id + ' g: ' + str(self.g) + ' rhs: ' + str(self.rhs)\n",
+    "\n",
+    "    def __repr__(self):\n",
+    "        return self.__str__()\n",
+    "\n",
+    "    def update_parents(self, parents):\n",
+    "        self.parents = parents\n",
+    "\n",
+    "\n",
+    "class Graph:\n",
+    "    def __init__(self):\n",
+    "        self.graph = {}\n",
+    "\n",
+    "    def __str__(self):\n",
+    "        msg = 'Graph:'\n",
+    "        for i in self.graph:\n",
+    "            msg += '\\n  node: ' + i + ' g: ' + \\\n",
+    "                str(self.graph[i].g) + ' rhs: ' + str(self.graph[i].rhs)\n",
+    "        return msg\n",
+    "\n",
+    "    def __repr__(self):\n",
+    "        return self.__str__()\n",
+    "\n",
+    "    def setStart(self, id):\n",
+    "        if(self.graph[id]):\n",
+    "            self.start = id\n",
+    "        else:\n",
+    "            raise ValueError('start id not in graph')\n",
+    "\n",
+    "    def setGoal(self, id):\n",
+    "        if(self.graph[id]):\n",
+    "            self.goal = id\n",
+    "        else:\n",
+    "            raise ValueError('goal id not in graph')\n",
+    "\n",
+    "\n",
+    "def addNodeToGraph(graph, id, neighbors, edge=1):\n",
+    "    node = Node(id)\n",
+    "    for i in neighbors:\n",
+    "        # print(i)\n",
+    "        node.parents[i] = edge\n",
+    "        node.children[i] = edge\n",
+    "    graph[id] = node\n",
+    "    return graph\n",
+    "\n",
+    "\n",
+    "def makeGraph():\n",
+    "    graph = {}\n",
+    "\n",
+    "    # 8-connected graph (w diagonals)\n",
+    "    # Impossible to find path - 2 obstacles in middle\n",
+    "    # graph = addNodeToGraph(graph, 'x1y1', ['x1y2', 'x2y1', 'x2y2'])\n",
+    "    # graph = addNodeToGraph(\n",
+    "    #     graph, 'x2y1', ['x1y1', 'x1y2', 'x3y1', 'x2y2', 'x3y2'], float('inf'))\n",
+    "    # graph = addNodeToGraph(graph, 'x1y2', ['x1y1', 'x2y1', 'x2y2'])\n",
+    "    # graph = addNodeToGraph(\n",
+    "    #     graph, 'x2y2', ['x1y1', 'x1y2', 'x3y1', 'x2y1', 'x3y2'], float('inf'))\n",
+    "    # graph = addNodeToGraph(graph, 'x3y1', ['x3y2', 'x2y1', 'x2y2'])\n",
+    "    # graph = addNodeToGraph(graph, 'x3y2', ['x3y1', 'x2y1', 'x2y2'])\n",
+    "\n",
+    "    # 8-connected graph (w diagonals)\n",
+    "    # Impossible to find path - 2 obstacles in middle\n",
+    "    # graph = addNodeToGraph(graph, 'x1y1', ['x1y2', 'x2y1', 'x2y2'])\n",
+    "    # graph = addNodeToGraph(\n",
+    "    #     graph, 'x2y1', ['x1y1', 'x1y2', 'x3y1', 'x2y2', 'x3y2'], float('inf'))\n",
+    "    # graph = addNodeToGraph(graph, 'x1y2', ['x1y1', 'x2y1', 'x2y2'])\n",
+    "    # graph = addNodeToGraph(\n",
+    "    #     graph, 'x2y2', ['x1y1', 'x1y2', 'x3y1', 'x2y1', 'x3y2'])\n",
+    "    # graph = addNodeToGraph(graph, 'x3y1', ['x3y2', 'x2y1', 'x2y2'])\n",
+    "    # graph = addNodeToGraph(graph, 'x3y2', ['x3y1', 'x2y1', 'x2y2'])\n",
+    "\n",
+    "    # 4-connected graph (w/out diagonals)\n",
+    "    graph = addNodeToGraph(graph, 'x1y1', ['x1y2', 'x2y1'])\n",
+    "    graph = addNodeToGraph(graph, 'x2y1', ['x1y1', 'x3y1', 'x2y2'])\n",
+    "    graph = addNodeToGraph(graph, 'x1y2', ['x1y1', 'x2y2'])\n",
+    "    graph = addNodeToGraph(graph, 'x2y2', ['x1y2', 'x2y1', 'x3y2'])\n",
+    "    graph = addNodeToGraph(graph, 'x3y1', ['x3y2', 'x2y1'])\n",
+    "    graph = addNodeToGraph(graph, 'x3y2', ['x3y1', 'x2y2'])\n",
+    "\n",
+    "    g = GridWorld(X_DIM, Y_DIM)\n",
+    "    # g.graph = graph\n",
+    "    # print(g)\n",
+    "    return g\n"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 4,
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "#grid\n",
+    "\n",
+    "\n",
+    "#from graph import Node, Graph\n",
+    "\n",
+    "\n",
+    "class GridWorld(Graph):\n",
+    "    def __init__(self, x_dim, y_dim, connect8=True):\n",
+    "        self.x_dim = x_dim\n",
+    "        self.y_dim = y_dim\n",
+    "        # First make an element for each row (height of grid)\n",
+    "        self.cells = [0] * y_dim\n",
+    "        # Go through each element and replace with row (width of grid)\n",
+    "        for i in range(y_dim):\n",
+    "            self.cells[i] = [0] * x_dim\n",
+    "        # will this be an 8-connected graph or 4-connected?\n",
+    "        self.connect8 = connect8\n",
+    "        self.graph = {}\n",
+    "\n",
+    "        self.generateGraphFromGrid()\n",
+    "        # self.printGrid()\n",
+    "\n",
+    "    def __str__(self):\n",
+    "        msg = 'Graph:'\n",
+    "        for i in self.graph:\n",
+    "            msg += '\\n  node: ' + i + ' g: ' + \\\n",
+    "                str(self.graph[i].g) + ' rhs: ' + str(self.graph[i].rhs) + \\\n",
+    "                ' neighbors: ' + str(self.graph[i].children)\n",
+    "        return msg\n",
+    "\n",
+    "    def __repr__(self):\n",
+    "        return self.__str__()\n",
+    "\n",
+    "    def printGrid(self):\n",
+    "        print('** GridWorld **')\n",
+    "        for row in self.cells:\n",
+    "            print(row)\n",
+    "\n",
+    "    def printGValues(self):\n",
+    "        for j in range(self.y_dim):\n",
+    "            str_msg = \"\"\n",
+    "            for i in range(self.x_dim):\n",
+    "                node_id = 'x' + str(i) + 'y' + str(j)\n",
+    "                node = self.graph[node_id]\n",
+    "                if node.g == float('inf'):\n",
+    "                    str_msg += ' - '\n",
+    "                else:\n",
+    "                    str_msg += ' ' + str(node.g) + ' '\n",
+    "            print(str_msg)\n",
+    "\n",
+    "    def generateGraphFromGrid(self):\n",
+    "        edge = 1\n",
+    "        for i in range(len(self.cells)):\n",
+    "            row = self.cells[i]\n",
+    "            for j in range(len(row)):\n",
+    "                # print('graph node ' + str(i) + ',' + str(j))\n",
+    "                node = Node('x' + str(i) + 'y' + str(j))\n",
+    "                if i > 0:  # not top row\n",
+    "                    node.parents['x' + str(i - 1) + 'y' + str(j)] = edge\n",
+    "                    node.children['x' + str(i - 1) + 'y' + str(j)] = edge\n",
+    "                if i + 1 < self.y_dim:  # not bottom row\n",
+    "                    node.parents['x' + str(i + 1) + 'y' + str(j)] = edge\n",
+    "                    node.children['x' + str(i + 1) + 'y' + str(j)] = edge\n",
+    "                if j > 0:  # not left col\n",
+    "                    node.parents['x' + str(i) + 'y' + str(j - 1)] = edge\n",
+    "                    node.children['x' + str(i) + 'y' + str(j - 1)] = edge\n",
+    "                if j + 1 < self.x_dim:  # not right col\n",
+    "                    node.parents['x' + str(i) + 'y' + str(j + 1)] = edge\n",
+    "                    node.children['x' + str(i) + 'y' + str(j + 1)] = edge\n",
+    "                self.graph['x' + str(i) + 'y' + str(j)] = node\n"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 5,
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "#d satr lite algorithm\n",
+    "\n",
+    "\n",
+    "import heapq\n",
+    "#from utils import stateNameToCoords\n",
+    "\n",
+    "\n",
+    "\n",
+    "def topKey(queue):\n",
+    "    queue.sort()\n",
+    "    # print(queue)\n",
+    "    if len(queue) > 0:\n",
+    "        return queue[0][:2]\n",
+    "    else:\n",
+    "        # print('empty queue!')\n",
+    "        return (float('inf'), float('inf'))\n",
+    "\n",
+    "\n",
+    "def heuristic_from_s(graph, id, s):\n",
+    "    x_distance = abs(int(id.split('x')[1][0]) - int(s.split('x')[1][0]))\n",
+    "    y_distance = abs(int(id.split('y')[1][0]) - int(s.split('y')[1][0]))\n",
+    "    return max(x_distance, y_distance)\n",
+    "\n",
+    "\n",
+    "def calculateKey(graph, id, s_current, k_m):\n",
+    "    return (min(graph.graph[id].g, graph.graph[id].rhs) + heuristic_from_s(graph, id, s_current) + k_m, min(graph.graph[id].g, graph.graph[id].rhs))\n",
+    "\n",
+    "\n",
+    "def updateVertex(graph, queue, id, s_current, k_m):\n",
+    "    s_goal = graph.goal\n",
+    "    if id != s_goal:\n",
+    "        min_rhs = float('inf')\n",
+    "        for i in graph.graph[id].children:\n",
+    "            min_rhs = min(\n",
+    "                min_rhs, graph.graph[i].g + graph.graph[id].children[i])\n",
+    "        graph.graph[id].rhs = min_rhs\n",
+    "    id_in_queue = [item for item in queue if id in item]\n",
+    "    if id_in_queue != []:\n",
+    "        if len(id_in_queue) != 1:\n",
+    "            raise ValueError('more than one ' + id + ' in the queue!')\n",
+    "        queue.remove(id_in_queue[0])\n",
+    "    if graph.graph[id].rhs != graph.graph[id].g:\n",
+    "        heapq.heappush(queue, calculateKey(graph, id, s_current, k_m) + (id,))\n",
+    "\n",
+    "\n",
+    "def computeShortestPath(graph, queue, s_start, k_m):\n",
+    "    while (graph.graph[s_start].rhs != graph.graph[s_start].g) or (topKey(queue) < calculateKey(graph, s_start, s_start, k_m)):\n",
+    "        # print(graph.graph[s_start])\n",
+    "        # print('topKey')\n",
+    "        # print(topKey(queue))\n",
+    "        # print('calculateKey')\n",
+    "        # print(calculateKey(graph, s_start, 0))\n",
+    "        k_old = topKey(queue)\n",
+    "        u = heapq.heappop(queue)[2]\n",
+    "        if k_old < calculateKey(graph, u, s_start, k_m):\n",
+    "            heapq.heappush(queue, calculateKey(graph, u, s_start, k_m) + (u,))\n",
+    "        elif graph.graph[u].g > graph.graph[u].rhs:\n",
+    "            graph.graph[u].g = graph.graph[u].rhs\n",
+    "            for i in graph.graph[u].parents:\n",
+    "                updateVertex(graph, queue, i, s_start, k_m)\n",
+    "        else:\n",
+    "            graph.graph[u].g = float('inf')\n",
+    "            updateVertex(graph, queue, u, s_start, k_m)\n",
+    "            for i in graph.graph[u].parents:\n",
+    "                updateVertex(graph, queue, i, s_start, k_m)\n",
+    "        # graph.printGValues()\n",
+    "\n",
+    "\n",
+    "def nextInShortestPath(graph, s_current):\n",
+    "    min_rhs = float('inf')\n",
+    "    s_next = None\n",
+    "    if graph.graph[s_current].rhs == float('inf'):\n",
+    "        print('You are done stuck')\n",
+    "    else:\n",
+    "        for i in graph.graph[s_current].children:\n",
+    "            # print(i)\n",
+    "            child_cost = graph.graph[i].g + graph.graph[s_current].children[i]\n",
+    "            # print(child_cost)\n",
+    "            if (child_cost) < min_rhs:\n",
+    "                min_rhs = child_cost\n",
+    "                s_next = i\n",
+    "        if s_next:\n",
+    "            return s_next\n",
+    "        else:\n",
+    "            raise ValueError('could not find child for transition!')\n",
+    "\n",
+    "\n",
+    "def scanForObstacles(graph, queue, s_current, scan_range, k_m):\n",
+    "    states_to_update = {}\n",
+    "    range_checked = 0\n",
+    "    if scan_range >= 1:\n",
+    "        for neighbor in graph.graph[s_current].children:\n",
+    "            neighbor_coords = stateNameToCoords(neighbor)\n",
+    "            states_to_update[neighbor] = graph.cells[neighbor_coords[1]\n",
+    "                                                     ][neighbor_coords[0]]\n",
+    "        range_checked = 1\n",
+    "    # print(states_to_update)\n",
+    "\n",
+    "    while range_checked < scan_range:\n",
+    "        new_set = {}\n",
+    "        for state in states_to_update:\n",
+    "            new_set[state] = states_to_update[state]\n",
+    "            for neighbor in graph.graph[state].children:\n",
+    "                if neighbor not in new_set:\n",
+    "                    neighbor_coords = stateNameToCoords(neighbor)\n",
+    "                    new_set[neighbor] = graph.cells[neighbor_coords[1]\n",
+    "                                                    ][neighbor_coords[0]]\n",
+    "        range_checked += 1\n",
+    "        states_to_update = new_set\n",
+    "\n",
+    "    new_obstacle = False\n",
+    "    for state in states_to_update:\n",
+    "        if states_to_update[state] < 0:  # found cell with obstacle\n",
+    "            # print('found obstacle in ', state)\n",
+    "            for neighbor in graph.graph[state].children:\n",
+    "                # first time to observe this obstacle where one wasn't before\n",
+    "                if(graph.graph[state].children[neighbor] != float('inf')):\n",
+    "                    neighbor_coords = stateNameToCoords(state)\n",
+    "                    graph.cells[neighbor_coords[1]][neighbor_coords[0]] = -2\n",
+    "                    graph.graph[neighbor].children[state] = float('inf')\n",
+    "                    graph.graph[state].children[neighbor] = float('inf')\n",
+    "                    updateVertex(graph, queue, state, s_current, k_m)\n",
+    "                    new_obstacle = True\n",
+    "        # elif states_to_update[state] == 0: #cell without obstacle\n",
+    "            # for neighbor in graph.graph[state].children:\n",
+    "                # if(graph.graph[state].children[neighbor] != float('inf')):\n",
+    "\n",
+    "    # print(graph)\n",
+    "    return new_obstacle\n",
+    "\n",
+    "\n",
+    "def moveAndRescan(graph, queue, s_current, scan_range, k_m):\n",
+    "    if(s_current == graph.goal):\n",
+    "        return 'goal', k_m\n",
+    "    else:\n",
+    "        s_last = s_current\n",
+    "        s_new = nextInShortestPath(graph, s_current)\n",
+    "        new_coords = stateNameToCoords(s_new)\n",
+    "\n",
+    "        if(graph.cells[new_coords[1]][new_coords[0]] == -1):  # just ran into new obstacle\n",
+    "            s_new = s_current  # need to hold tight and scan/replan first\n",
+    "\n",
+    "        results = scanForObstacles(graph, queue, s_new, scan_range, k_m)\n",
+    "        # print(graph)\n",
+    "        k_m += heuristic_from_s(graph, s_last, s_new)\n",
+    "        computeShortestPath(graph, queue, s_current, k_m)\n",
+    "\n",
+    "        return s_new, k_m\n",
+    "\n",
+    "\n",
+    "def initDStarLite(graph, queue, s_start, s_goal, k_m):\n",
+    "    graph.graph[s_goal].rhs = 0\n",
+    "    heapq.heappush(queue, calculateKey(\n",
+    "        graph, s_goal, s_start, k_m) + (s_goal,))\n",
+    "    computeShortestPath(graph, queue, s_start, k_m)\n",
+    "\n",
+    "    return (graph, queue, k_m)\n"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 6,
+   "metadata": {},
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "pygame 2.0.0 (SDL 2.0.12, python 3.8.3)\n",
+      "Hello from the pygame community. https://www.pygame.org/contribute.html\n",
+      "You are done stuck\n"
+     ]
+    },
+    {
+     "ename": "AttributeError",
+     "evalue": "'NoneType' object has no attribute 'split'",
+     "output_type": "error",
+     "traceback": [
+      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
+      "\u001b[1;31mAttributeError\u001b[0m                            Traceback (most recent call last)",
+      "\u001b[1;32m<ipython-input-6-3adb65508fbd>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[0;32m     92\u001b[0m             \u001b[1;32melif\u001b[0m \u001b[0mevent\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mtype\u001b[0m \u001b[1;33m==\u001b[0m \u001b[0mpygame\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mKEYDOWN\u001b[0m \u001b[1;32mand\u001b[0m \u001b[0mevent\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mkey\u001b[0m \u001b[1;33m==\u001b[0m \u001b[0mpygame\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mK_SPACE\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     93\u001b[0m                 \u001b[1;31m# print('space bar! call next action')\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m---> 94\u001b[1;33m                 s_new, k_m = moveAndRescan(\n\u001b[0m\u001b[0;32m     95\u001b[0m                     graph, queue, s_current, VIEWING_RANGE, k_m)\n\u001b[0;32m     96\u001b[0m                 \u001b[1;32mif\u001b[0m \u001b[0ms_new\u001b[0m \u001b[1;33m==\u001b[0m \u001b[1;34m'goal'\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
+      "\u001b[1;32m<ipython-input-5-ea5a16cd02d4>\u001b[0m in \u001b[0;36mmoveAndRescan\u001b[1;34m(graph, queue, s_current, scan_range, k_m)\u001b[0m\n\u001b[0;32m    136\u001b[0m         \u001b[0ms_last\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0ms_current\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    137\u001b[0m         \u001b[0ms_new\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mnextInShortestPath\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mgraph\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0ms_current\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 138\u001b[1;33m         \u001b[0mnew_coords\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mstateNameToCoords\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ms_new\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    139\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    140\u001b[0m         \u001b[1;32mif\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mgraph\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mcells\u001b[0m\u001b[1;33m[\u001b[0m\u001b[0mnew_coords\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m[\u001b[0m\u001b[0mnew_coords\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m]\u001b[0m \u001b[1;33m==\u001b[0m \u001b[1;33m-\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m  \u001b[1;31m# just ran into new obstacle\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
+      "\u001b[1;32m<ipython-input-2-ca0024467327>\u001b[0m in \u001b[0;36mstateNameToCoords\u001b[1;34m(name)\u001b[0m\n\u001b[0;32m      2\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      3\u001b[0m \u001b[1;32mdef\u001b[0m \u001b[0mstateNameToCoords\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mname\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 4\u001b[1;33m     \u001b[1;32mreturn\u001b[0m \u001b[1;33m[\u001b[0m\u001b[0mint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mname\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0msplit\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'x'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0msplit\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'y'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mname\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0msplit\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'x'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0msplit\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'y'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m",
+      "\u001b[1;31mAttributeError\u001b[0m: 'NoneType' object has no attribute 'split'"
+     ]
+    }
+   ],
+   "source": [
+    "import heapq\n",
+    "import pygame\n",
+    "\n",
+    "#from graph import Node, Graph\n",
+    "#from grid import GridWorld\n",
+    "#from utils import stateNameToCoords\n",
+    "#from d_star_lite import initDStarLite, moveAndRescan\n",
+    "\n",
+    "# Define some colors\n",
+    "BLACK = (0, 0, 0)\n",
+    "WHITE = (255, 255, 255)\n",
+    "GREEN = (0, 255, 0)\n",
+    "RED = (255, 0, 0)\n",
+    "GRAY1 = (145, 145, 102)\n",
+    "GRAY2 = (77, 77, 51)\n",
+    "BLUE = (0, 0, 80)\n",
+    "\n",
+    "colors = {\n",
+    "    0: WHITE,\n",
+    "    1: GREEN,\n",
+    "    -1: GRAY1,\n",
+    "    -2: GRAY2\n",
+    "}\n",
+    "\n",
+    "# This sets the WIDTH and HEIGHT of each grid location\n",
+    "WIDTH = 40\n",
+    "HEIGHT = 40\n",
+    "\n",
+    "# This sets the margin between each cell\n",
+    "MARGIN = 5\n",
+    "\n",
+    "# Create a 2 dimensional array. A two dimensional\n",
+    "# array is simply a list of lists.\n",
+    "grid = []\n",
+    "for row in range(10):\n",
+    "    # Add an empty array that will hold each cell\n",
+    "    # in this row\n",
+    "    grid.append([])\n",
+    "    for column in range(10):\n",
+    "        grid[row].append(0)  # Append a cell\n",
+    "\n",
+    "# Set row 1, cell 5 to one. (Remember rows and\n",
+    "# column numbers start at zero.)\n",
+    "grid[1][5] = 1\n",
+    "\n",
+    "# Initialize pygame\n",
+    "pygame.init()\n",
+    "\n",
+    "X_DIM = 12\n",
+    "Y_DIM = 12\n",
+    "VIEWING_RANGE = 3\n",
+    "\n",
+    "\n",
+    "# Set the HEIGHT and WIDTH of the screen\n",
+    "WINDOW_SIZE = [(WIDTH + MARGIN) * X_DIM + MARGIN,\n",
+    "               (HEIGHT + MARGIN) * Y_DIM + MARGIN]\n",
+    "screen = pygame.display.set_mode(WINDOW_SIZE)\n",
+    "\n",
+    "# Set title of screen\n",
+    "pygame.display.set_caption(\"D* Lite Path Planning\")\n",
+    "\n",
+    "# Loop until the user clicks the close button.\n",
+    "done = False\n",
+    "\n",
+    "# Used to manage how fast the screen updates\n",
+    "clock = pygame.time.Clock()\n",
+    "\n",
+    "if __name__ == \"__main__\":\n",
+    "    graph = GridWorld(X_DIM, Y_DIM)\n",
+    "    s_start = 'x1y2'\n",
+    "    s_goal = 'x5y4'\n",
+    "    goal_coords = stateNameToCoords(s_goal)\n",
+    "\n",
+    "    graph.setStart(s_start)\n",
+    "    graph.setGoal(s_goal)\n",
+    "    k_m = 0\n",
+    "    s_last = s_start\n",
+    "    queue = []\n",
+    "\n",
+    "    graph, queue, k_m = initDStarLite(graph, queue, s_start, s_goal, k_m)\n",
+    "\n",
+    "    s_current = s_start\n",
+    "    pos_coords = stateNameToCoords(s_current)\n",
+    "\n",
+    "    basicfont = pygame.font.SysFont('Comic Sans MS', 36)\n",
+    "\n",
+    "    # -------- Main Program Loop -----------\n",
+    "    while not done:\n",
+    "        for event in pygame.event.get():  # User did something\n",
+    "            if event.type == pygame.QUIT:  # If user clicked close\n",
+    "                done = True  # Flag that we are done so we exit this loop\n",
+    "            elif event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:\n",
+    "                # print('space bar! call next action')\n",
+    "                s_new, k_m = moveAndRescan(\n",
+    "                    graph, queue, s_current, VIEWING_RANGE, k_m)\n",
+    "                if s_new == 'goal':\n",
+    "                    print('Goal Reached!')\n",
+    "                    done = True\n",
+    "                else:\n",
+    "                    # print('setting s_current to ', s_new)\n",
+    "                    s_current = s_new\n",
+    "                    pos_coords = stateNameToCoords(s_current)\n",
+    "                    # print('got pos coords: ', pos_coords)\n",
+    "\n",
+    "            elif event.type == pygame.MOUSEBUTTONDOWN:\n",
+    "                # User clicks the mouse. Get the position\n",
+    "                pos = pygame.mouse.get_pos()\n",
+    "                # Change the x/y screen coordinates to grid coordinates\n",
+    "                column = pos[0] // (WIDTH + MARGIN)\n",
+    "                row = pos[1] // (HEIGHT + MARGIN)\n",
+    "                # Set that location to one\n",
+    "                if(graph.cells[row][column] == 0):\n",
+    "                    graph.cells[row][column] = -1\n",
+    "\n",
+    "        # Set the screen background\n",
+    "        screen.fill(BLACK)\n",
+    "\n",
+    "        # Draw the grid\n",
+    "        for row in range(Y_DIM):\n",
+    "            for column in range(X_DIM):\n",
+    "                color = WHITE\n",
+    "                # if grid[row][column] == 1:\n",
+    "                #     color = GREEN\n",
+    "                pygame.draw.rect(screen, colors[graph.cells[row][column]],\n",
+    "                                 [(MARGIN + WIDTH) * column + MARGIN,\n",
+    "                                  (MARGIN + HEIGHT) * row + MARGIN, WIDTH, HEIGHT])\n",
+    "                node_name = 'x' + str(column) + 'y' + str(row)\n",
+    "                if(graph.graph[node_name].g != float('inf')):\n",
+    "                    # text = basicfont.render(\n",
+    "                    # str(graph.graph[node_name].g), True, (0, 0, 200), (255,\n",
+    "                    # 255, 255))\n",
+    "                    text = basicfont.render(\n",
+    "                        str(graph.graph[node_name].g), True, (0, 0, 200))\n",
+    "                    textrect = text.get_rect()\n",
+    "                    textrect.centerx = int(\n",
+    "                        column * (WIDTH + MARGIN) + WIDTH / 2) + MARGIN\n",
+    "                    textrect.centery = int(\n",
+    "                        row * (HEIGHT + MARGIN) + HEIGHT / 2) + MARGIN\n",
+    "                    screen.blit(text, textrect)\n",
+    "\n",
+    "        # fill in goal cell with GREEN\n",
+    "        pygame.draw.rect(screen, GREEN, [(MARGIN + WIDTH) * goal_coords[0] + MARGIN,\n",
+    "                                         (MARGIN + HEIGHT) * goal_coords[1] + MARGIN, WIDTH, HEIGHT])\n",
+    "        # print('drawing robot pos_coords: ', pos_coords)\n",
+    "        # draw moving robot, based on pos_coords\n",
+    "        robot_center = [int(pos_coords[0] * (WIDTH + MARGIN) + WIDTH / 2) +\n",
+    "                        MARGIN, int(pos_coords[1] * (HEIGHT + MARGIN) + HEIGHT / 2) + MARGIN]\n",
+    "        pygame.draw.circle(screen, RED, robot_center, int(WIDTH / 2) - 2)\n",
+    "\n",
+    "        # draw robot viewing range\n",
+    "        pygame.draw.rect(\n",
+    "            screen, BLUE, [robot_center[0] - VIEWING_RANGE * (WIDTH + MARGIN), robot_center[1] - VIEWING_RANGE * (HEIGHT + MARGIN), 2 * VIEWING_RANGE * (WIDTH + MARGIN), 2 * VIEWING_RANGE * (HEIGHT + MARGIN)], 2)\n",
+    "\n",
+    "        # Limit to 60 frames per second\n",
+    "        clock.tick(20)\n",
+    "\n",
+    "        # Go ahead and update the screen with what we've drawn.\n",
+    "        pygame.display.flip()\n",
+    "\n",
+    "    # Be IDLE friendly. If you forget this line, the program will 'hang'\n",
+    "    # on exit.\n",
+    "    pygame.quit()\n"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {},
+   "outputs": [],
+   "source": []
+  }
+ ],
+ "metadata": {
+  "colab": {
+   "collapsed_sections": [],
+   "name": "D Star Lite.ipynb",
+   "provenance": []
+  },
+  "kernelspec": {
+   "display_name": "Python 3",
+   "language": "python",
+   "name": "python3"
+  },
+  "language_info": {
+   "codemirror_mode": {
+    "name": "ipython",
+    "version": 3
+   },
+   "file_extension": ".py",
+   "mimetype": "text/x-python",
+   "name": "python",
+   "nbconvert_exporter": "python",
+   "pygments_lexer": "ipython3",
+   "version": "3.8.3"
+  }
+ },
+ "nbformat": 4,
+ "nbformat_minor": 1
+}
Index: graph.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/graph.txt b/graph.txt
new file mode 100644
--- /dev/null	(date 1609983342816)
+++ b/graph.txt	(date 1609983342816)
@@ -0,0 +1,21 @@
+1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00
+1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00
+1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00
+1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00
+1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00
+1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00
+1.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00
+1.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00
+1.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00
+1.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00
+1.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00
+1.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00
+1.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00
+1.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00
+1.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00
+1.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00
+1.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00
+1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00
+1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00
+1.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 0.000000000000000000e+00 1.000000000000000000e+00
+1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00 1.000000000000000000e+00
